# Ralph Progress Log

## Codebase Patterns

- **Migration files**: Located at `apps/studio/drizzle/migrations/` with naming convention `XXXX_description.sql`
- **SQLite column naming**: Uses snake_case for columns (e.g., `first_name`, `created_at`)
- **Timestamps**: Use `text` type with `DEFAULT (datetime('now'))` for SQLite compatibility
- **Foreign keys**: Defined inline with column using `FOREIGN KEY ... REFERENCES` syntax
- **Indexes**: Created with `--> statement-breakpoint` separator between SQL statements
- **JSON fields**: Stored as `text` type (SQLite doesn't have native JSON type)
- **Pre-existing issues**: Typecheck error exists in Login.tsx:52 on main branch

---

## Iterations

### Iteration: 2026-01-20

**Story:** US-001 - Create email marketing database schema migration
**Status:** Complete

**What was done:**

- Created migration file at `drizzle/migrations/0005_add_email_marketing.sql`
- Implemented 8 tables: `subscribers`, `segments`, `segment_subscribers`, `email_templates`, `email_components`, `campaigns`, `email_sends`, `email_events`
- Added proper foreign key relationships between tables
- Created indexes on frequently queried columns (email, shopify_customer_id, status, campaign_id)
- Verified build passes (typecheck has pre-existing error unrelated to this change)

**Files changed:**

- `apps/studio/drizzle/migrations/0005_add_email_marketing.sql` (created)
- `backlog/backlog.json` (updated passes status)

**Learnings for future iterations:**

- SQLite uses `text` type for JSON data, datetime, and enums
- Migration file uses `--> statement-breakpoint` to separate SQL statements
- Build verification is sufficient when typecheck has pre-existing errors on main
- Status enum values are stored as text strings in SQLite (not native enums)

### Iteration: 2026-01-20 (continued)

**Story:** US-002 - Add Drizzle schema definitions for email marketing tables
**Status:** Complete

**What was done:**

- Added 8 Drizzle table definitions to `apps/studio/server/db/schema.ts`
- Tables defined: `subscribers`, `segments`, `segmentSubscribers`, `emailTemplates`, `emailComponents`, `campaigns`, `emailSends`, `emailEvents`
- Added Drizzle relations for all table relationships using `relations()` helper
- Exported Select and Insert types for each table (e.g., `Subscriber`, `NewSubscriber`)
- Used `text()` with `enum` option for status fields to match SQLite storage
- Verified build passes successfully

**Files changed:**

- `apps/studio/server/db/schema.ts` (modified - added 251 lines)
- `backlog/backlog.json` (updated US-002 passes status)

**Learnings for future iterations:**

- Drizzle uses `primaryKey({columns: [...]})` for composite primary keys in SQLite
- Relations are defined separately from tables using `relations()` from drizzle-orm
- Type inference uses `$inferSelect` and `$inferInsert` on table definitions
- Enum options in text() provide TypeScript typing but store as plain text in SQLite

### Iteration: 2026-01-20 (continued)

**Story:** US-003 - Create subscriber CRUD API routes
**Status:** Complete

**What was done:**

- Created `apps/studio/server/routes/email.ts` with subscriber CRUD endpoints
- Implemented `GET /api/email/subscribers` with pagination and filters (status, search, segmentId)
- Implemented `GET /api/email/subscribers/:id` returning subscriber with segment memberships
- Implemented `POST /api/email/subscribers` with email validation and duplicate checking
- Implemented `PATCH /api/email/subscribers/:id` for updating subscriber fields
- Implemented `DELETE /api/email/subscribers/:id` as soft-delete (sets status to 'unsubscribed')
- Registered email routes in `apps/studio/server/index.ts`
- All routes require authentication via authMiddleware

**Files changed:**

- `apps/studio/server/routes/email.ts` (created)
- `apps/studio/server/index.ts` (modified - added email routes)
- `backlog/backlog.json` (updated US-003 passes status)

**Learnings for future iterations:**

- Hono routes follow pattern: create Hono instance, apply middleware, define routes, export
- Status enum fields need explicit type assertion when comparing with query params (string â†’ enum type)
- Drizzle `inArray` operator useful for filtering by segment membership
- Use zValidator from @hono/zod-validator for request body validation
- Soft deletes preferred for subscriber management to preserve data integrity

### Iteration: 2026-01-20 (continued)

**Story:** US-004 - Implement Shopify customer sync service
**Status:** Complete

**What was done:**

- Created `apps/studio/server/services/shopifySync.ts` with Shopify customer sync functionality
- Implemented `syncCustomersFromShopify` function using Shopify Admin GraphQL API
- Used cursor-based pagination to handle stores with >250 customers (Shopify's maximum per request)
- Creates new subscribers for Shopify customers without existing records
- Updates existing subscribers if email/name/shopifyCustomerId changed
- Respects unsubscribed/bounced status - does not re-subscribe users
- Sets `source` field to 'shopify_sync' for new subscribers
- Checks Shopify's `emailMarketingConsent.marketingState` for initial subscription status
- Added SHOPIFY_ADMIN_API_TOKEN and SHOPIFY_STORE_DOMAIN to Env interface
- Returns sync stats object with created, updated, skipped, and total counts

**Files changed:**

- `apps/studio/server/services/shopifySync.ts` (created)
- `apps/studio/server/index.ts` (modified - added Shopify env vars to Env interface)
- `backlog/backlog.json` (updated US-004 passes status)

**Learnings for future iterations:**

- Shopify Admin GraphQL API uses cursor-based pagination via `after` parameter
- Shopify global IDs format: `gid://shopify/Customer/123` - extract numeric ID from last segment
- Shopify API version format: `2024-01` in URL path
- `X-Shopify-Access-Token` header required for authentication
- `emailMarketingConsent.marketingState` can be 'SUBSCRIBED', 'UNSUBSCRIBED', 'NOT_SUBSCRIBED', etc.
- Type `D1Database` imported from `@cloudflare/workers-types` for Cloudflare D1 database parameter

### Iteration: 2026-01-20 (continued)

**Story:** US-005 - Add Shopify customer webhooks endpoint
**Status:** Complete

**What was done:**

- Added `POST /api/email/webhooks/shopify` endpoint to `apps/studio/server/routes/email.ts`
- Implemented HMAC signature validation using Web Crypto API (`crypto.subtle`)
- Handled `customers/create` topic - creates new subscriber or updates existing with Shopify ID
- Handled `customers/update` topic - updates subscriber email/name if changed
- Handled `customers/delete` topic - marks subscriber as unsubscribed (soft delete)
- Added SHOPIFY_WEBHOOK_SECRET to Env interface
- Webhook endpoint does NOT require auth middleware - uses HMAC validation instead
- Returns 200 OK quickly to prevent Shopify retries on errors
- Logs all webhook events for debugging

**Files changed:**

- `apps/studio/server/routes/email.ts` (modified - added ~250 lines for webhook handler)
- `apps/studio/server/index.ts` (modified - added SHOPIFY_WEBHOOK_SECRET to Env interface)
- `backlog/backlog.json` (updated US-005 passes status)

**Learnings for future iterations:**

- Shopify webhook headers: `X-Shopify-Topic` for event type, `X-Shopify-Hmac-Sha256` for signature
- HMAC validation uses Web Crypto API: `crypto.subtle.importKey` + `crypto.subtle.sign`
- Shopify webhook payload uses snake_case (e.g., `first_name`, `email_marketing_consent`)
- Shopify webhook `email_marketing_consent.state` values: `subscribed`, `not_subscribed`, `unsubscribed`
- Webhook routes need to be defined BEFORE applying auth middleware via `emailRoutes.use('/path/*', authMiddleware)`
- Always return 200 OK to Shopify webhooks to prevent retries, even on internal errors

### Iteration: 2026-01-20 (continued)

**Story:** US-006 - Create subscribers list page UI
**Status:** Complete

**What was done:**

- Created `apps/studio/client/pages/email/Subscribers.tsx` with full subscriber list UI
- Implemented table with columns: Email, Name, Status, Source, Subscribed Date
- Added search input that filters by email or name (resets page to 1 on change)
- Added status filter dropdown with All Statuses, Active, Unsubscribed, Bounced options
- Implemented pagination with Previous/Next buttons (50 subscribers per page)
- Shows total subscriber count and active count in header
- Created StatusBadge component with color-coded badges (green/gray/red)
- Added loading spinner while fetching data
- Added empty state message when no subscribers match filters
- Added email API methods to `apps/studio/client/lib/api.ts` for all subscriber CRUD operations
- Registered `/email/subscribers` route in `apps/studio/client/App.tsx`
- Verified UI in browser using chrome-devtools MCP

**Files changed:**

- `apps/studio/client/pages/email/Subscribers.tsx` (created)
- `apps/studio/client/lib/api.ts` (modified - added email.subscribers API methods)
- `apps/studio/client/App.tsx` (modified - added route and import)
- `backlog/backlog.json` (updated US-006 passes status)

**Learnings for future iterations:**

- UI pages follow pattern from seo/Tracking.tsx: useState for filters, useQuery for data fetching
- Table styling: rounded-lg border bg-card wrapper, bg-muted/50 header row, divide-y divide-border body
- Status badges use bg-color/20 with text-color for consistent styling
- API client pattern: nested objects with methods that return `fetch().then(handleResponse<Type>)`
- Pagination resets to page 1 when filters change to avoid showing empty results
- Dev login available at localhost for testing without auth flow

### Iteration: 2026-01-20 (continued)

**Story:** US-007 - Add navigation for email marketing section
**Status:** Complete

**What was done:**

- Updated `apps/studio/client/components/layout/Sidebar.tsx` to add Email section
- Created inline MailIcon component (SVG envelope icon)
- Added Email section to navigation array with sub-items: Subscribers, Templates, Campaigns
- Updated section header rendering to display icon when present (using flex layout)
- Active state highlighting already handled by existing NavLink `isActive` prop
- Verified in browser: Email section with icon visible, navigation works, active state highlights correctly

**Files changed:**

- `apps/studio/client/components/layout/Sidebar.tsx` (modified - added 29 lines)
- `backlog/backlog.json` (updated US-007 passes status)

**Learnings for future iterations:**

- Sidebar sections can optionally have an `icon` property (React component)
- Icons rendered conditionally: `{section.icon && <section.icon className="h-4 w-4" />}`
- NavLink from react-router-dom provides `isActive` callback for active state styling
- Inline SVG icons work well when no icon library is installed

### Iteration: 2026-01-20 (continued)

**Story:** US-008 - Create segment CRUD API routes
**Status:** Complete

**What was done:**

- Added 5 segment CRUD endpoints to `apps/studio/server/routes/email.ts`
- `GET /api/email/segments` returns all segments ordered by createdAt (desc)
- `GET /api/email/segments/:id` returns segment with paginated subscriber list (includes subscriber details via join)
- `POST /api/email/segments` creates custom segment with name and optional filters JSON
- `PATCH /api/email/segments/:id` updates segment name and/or filters
- `DELETE /api/email/segments/:id` deletes segment (only custom type allowed - Shopify synced segments return 403)
- All segment routes require authentication via existing `emailRoutes.use('/segments/*', authMiddleware)`

**Files changed:**

- `apps/studio/server/routes/email.ts` (modified - added 182 lines for segment CRUD)
- `backlog/backlog.json` (updated US-008 passes status)

**Learnings for future iterations:**

- Segment DELETE endpoint should not allow deleting Shopify-synced segments to prevent data inconsistency
- JOIN with subscribers table in GET /segments/:id allows returning subscriber details in segment member list
- Pagination pattern reused from subscribers endpoint: count query + data query with limit/offset
- Filters stored as JSON string using `JSON.stringify(data.filters)`

### Iteration: 2026-01-20 (continued)

**Story:** US-009 - Implement Shopify segments sync
**Status:** Complete

**What was done:**

- Added `syncSegmentsFromShopify` function to `apps/studio/server/services/shopifySync.ts`
- Implemented `SEGMENTS_QUERY` GraphQL query to fetch all segments from Shopify
- Implemented `SEGMENT_MEMBERS_QUERY` GraphQL query with `customerSegmentMembers` to fetch segment members
- Added `fetchShopifySegments` and `fetchShopifySegmentMembers` helper functions with pagination support
- Function creates/updates segments with `type: 'shopify_sync'` and stores `shopifySegmentId`
- `syncSegmentMembers` helper syncs members by comparing Shopify member IDs with local segment memberships
- Adds new members to `segmentSubscribers` table, removes members no longer in Shopify segment
- Updates `subscriberCount` on segment after member sync
- Handles pagination for segments with >1000 members (uses cursor-based pagination)
- Added `SegmentSyncStats` interface for return type

**Files changed:**

- `apps/studio/server/services/shopifySync.ts` (modified - added ~270 lines)
- `backlog/backlog.json` (updated US-009 passes status)

**Learnings for future iterations:**

- Shopify `segments` query returns segments with `id`, `name`, `creationDate`, `lastEditDate`
- Shopify `customerSegmentMembers` query requires segment GID (not numeric ID) as `segmentId` parameter
- Segment member sync requires joining `segmentSubscribers` with `subscribers` to get `shopifyCustomerId` for comparison
- Use Set for efficient membership comparison when syncing (O(1) lookup vs O(n) array includes)
- `drizzle-orm` delete with compound where clause uses `and()` helper: `and(eq(a, x), eq(b, y))`

### Iteration: 2026-01-20 (continued)

**Story:** US-010 - Add manual segment sync trigger endpoint
**Status:** Complete

**What was done:**

- Added `POST /api/email/segments/sync` endpoint to `apps/studio/server/routes/email.ts`
- Implemented rate limiting (5 minutes between syncs) using in-memory tracking
- Uses `c.executionCtx.waitUntil()` for async execution - returns immediately with acknowledgment
- Syncs both customers and segments from Shopify in sequence
- Resets rate limit on failure so user can retry sooner
- Validates required environment variables (SHOPIFY_ADMIN_API_TOKEN, SHOPIFY_STORE_DOMAIN)
- Returns 429 Too Many Requests if rate limited, with retryAfterSeconds

**Files changed:**

- `apps/studio/server/routes/email.ts` (modified - added ~78 lines)
- `backlog/backlog.json` (updated US-010 passes status)

**Learnings for future iterations:**

- Cloudflare Workers use `c.executionCtx.waitUntil()` for async background tasks
- In-memory rate limiting works per-isolate; for production may need KV/durable objects
- Rate limit should be reset on failure to allow retry
- Return 429 status with `retryAfterSeconds` for rate-limited requests

### Iteration: 2026-01-20 (continued)

**Story:** US-011 - Create Header email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/Header.tsx` using @react-email/components
- Implemented Header component with Img and Section from @react-email/components
- Props: `logoUrl` (string, required) and `backgroundColor` (string, default #1a1a1a)
- Logo centered with 40px height, 24px top/bottom padding
- Exported `HeaderSchema` JSON for template editor integration
- Exported `HeaderDefaultProps` with sensible defaults
- Installed @react-email/components and @react-email/render dependencies

**Files changed:**

- `apps/studio/server/email-components/Header.tsx` (created)
- `apps/studio/package.json` (modified - added @react-email dependencies)
- `pnpm-lock.yaml` (updated)
- `backlog/backlog.json` (updated US-011 passes status)

**Learnings for future iterations:**

- @react-email/components provides email-safe React components (Img, Section, Row, Column, etc.)
- Email components should export both the component and a schema JSON for the editor
- Schema JSON should define prop types, labels, descriptions, defaults, and required fields
- Use `as const` for schema to get better TypeScript inference
- DefaultProps export useful for initializing component instances in the editor

### Iteration: 2026-01-20 (continued)

**Story:** US-012 - Create Hero email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/Hero.tsx` with all required props
- Props implemented: headline, subheadline, imageUrl, buttonText, buttonUrl, backgroundColor
- Headline styled with Founders Grotesk font fallback at 32px, weight 600
- Subheadline styled with ITC Avant Garde Gothic font fallback at 18px
- Button styled with Wakey yellow (#FAD103) background, 16px 32px padding, 8px border-radius
- Image has max-width: 100% for responsive scaling
- Text props support `{{firstName}}` style variable interpolation (rendered at template level)
- Exported HeroSchema JSON with all prop definitions for editor
- Exported HeroDefaultProps with sensible defaults

**Files changed:**

- `apps/studio/server/email-components/Hero.tsx` (created)
- `backlog/backlog.json` (updated US-012 passes status)

**Learnings for future iterations:**

- @react-email/components Button component uses `href` prop (not `url`)
- Variable interpolation `{{firstName}}` is passed through as-is; interpolation happens at render time
- Use optional chaining in render for optional props (e.g., `{imageUrl && <Img ... />}`)
- Text component from @react-email/components wraps content in inline styles for email compatibility

### Iteration: 2026-01-20 (continued)

**Story:** US-013 - Create TextBlock email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/TextBlock.tsx` for body text content
- Implemented TextBlock component with content, alignment, and fontSize props
- alignment options: 'left', 'center', 'right' (default: left)
- fontSize options: 'paragraph' (16px), 'small' (14px) (default: paragraph)
- Uses ITC Avant Garde Gothic font fallback with line-height 1.6 for readability
- Supports basic HTML (bold, italic, links) via dangerouslySetInnerHTML
- Exported TextBlockSchema JSON with textarea for content, select for alignment/fontSize
- Exported TextBlockDefaultProps with sensible defaults

**Files changed:**

- `apps/studio/server/email-components/TextBlock.tsx` (created)
- `backlog/backlog.json` (updated US-013 passes status)

**Learnings for future iterations:**

- Use `dangerouslySetInnerHTML` for components that accept HTML content (bold, italic, links)
- Select schema fields need `options` array with `{value, label}` objects
- Keep font size options simple (paragraph/small) rather than arbitrary pixel values
- Text component styling uses inline `style` prop for email client compatibility

### Iteration: 2026-01-20 (continued)

**Story:** US-014 - Create CallToAction email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/CallToAction.tsx` for CTA buttons
- Implemented CallToAction component with text, url, and variant props
- Primary variant: #FAD103 background, #1a1a1a text (Wakey yellow)
- Secondary variant: transparent background, #FAD103 border and text
- Button uses Founders Grotesk font, 16px 32px padding, 8px border-radius
- Button centered in Section with 24px padding
- Exported CallToActionSchema JSON with select options for variant
- Exported CallToActionDefaultProps with sensible defaults
- Build passes (pre-existing typecheck error in Login.tsx unrelated)

**Files changed:**

- `apps/studio/server/email-components/CallToAction.tsx` (created)
- `backlog/backlog.json` (updated US-014 passes status)

**Learnings for future iterations:**

- @react-email/components Button uses `href` prop for the URL destination
- Variant styling uses conditional expressions based on props (e.g., `isPrimary ? 'value1' : 'value2'`)
- Email buttons need explicit `display: 'inline-block'` for proper rendering
- Secondary button variant uses transparent background with border for outline effect

### Iteration: 2026-01-20 (continued)

**Story:** US-015 - Create ProductGrid email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/ProductGrid.tsx` for showcasing products
- Implemented ProductGrid component with products array and columns (2 or 3) props
- Product interface: `{imageUrl, title, price, url}`
- Uses Row and Column from @react-email/components for grid layout
- Products limited to max 6 using `.slice(0, 6)`
- Each product wrapped in Link, shows image (with border-radius), title, and price
- Title uses Founders Grotesk font, price uses muted color (#666666)
- Empty columns added to maintain grid alignment when row is not full
- Exported ProductGridSchema with array type and itemSchema for editor
- Exported ProductGridDefaultProps with 2 sample products
- Build passes (pre-existing typecheck error in Login.tsx unrelated)

**Files changed:**

- `apps/studio/server/email-components/ProductGrid.tsx` (created)
- `backlog/backlog.json` (updated US-015 passes status)

**Learnings for future iterations:**

- Array props in schema use `type: 'array'` with `itemSchema` object defining item fields
- Row/Column components from @react-email work for email-compatible grid layouts
- Use percentage widths for columns (50% for 2-col, 33.33% for 3-col)
- Add empty Column components to fill rows that aren't complete to maintain alignment
- Link component wraps entire product card for click-through to product URL

### Iteration: 2026-01-20 (continued)

**Story:** US-016 - Create Footer email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/Footer.tsx` for CAN-SPAM compliant email footers
- Implemented Footer component with unsubscribeUrl, address, and socialLinks props
- socialLinks accepts array of `{platform: 'instagram' | 'tiktok', url: string}` objects
- Physical address displayed in muted text (#666666) for CAN-SPAM compliance
- Unsubscribe link underlined for prominence and easy clickability
- Created inline SVG icons for Instagram and TikTok (no external dependencies)
- Social icons render conditionally based on socialLinks array
- Dark background (#1a1a1a) matches Wakey brand
- Exported FooterSchema JSON with array itemSchema for socialLinks
- Exported FooterDefaultProps with sample Instagram/TikTok links

**Files changed:**

- `apps/studio/server/email-components/Footer.tsx` (created)
- `backlog/backlog.json` (updated US-016 passes status)

**Learnings for future iterations:**

- Inline SVG components work well for email icons (no external library needed)
- CAN-SPAM requires physical address in all marketing emails
- Unsubscribe link should be underlined/prominent for legal compliance
- Social links array schema uses `itemSchema` with nested field definitions
- `{{unsubscribeUrl}}` placeholder will be interpolated at send time with signed token URL

### Iteration: 2026-01-20 (continued)

**Story:** US-017 - Create Divider email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/Divider.tsx` for visual separation
- Implemented Divider component with color and spacing props
- Uses Hr component from @react-email/components for horizontal rule
- color prop defaults to #e0e0e0 (light gray)
- spacing prop: 'small' (8px), 'medium' (16px), 'large' (32px)
- Wraps Hr in Section for padding control
- Exported DividerSchema JSON for template editor with color picker and select
- Exported DividerDefaultProps with sensible defaults

**Files changed:**

- `apps/studio/server/email-components/Divider.tsx` (created)
- `backlog/backlog.json` (updated US-017 passes status)

**Learnings for future iterations:**

- @react-email/components provides Hr component for horizontal rules
- Spacing can be controlled via Section wrapper with padding styles
- Use `as const` on SPACING_MAP for better TypeScript inference
- Color picker schema type uses `type: 'color'`

### Iteration: 2026-01-20 (continued)

**Story:** US-018 - Create component registry and renderer service
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/index.ts` as central component registry
- Registry exports all 7 components (Header, Hero, TextBlock, CallToAction, ProductGrid, Footer, Divider) with schemas and default props
- Created `apps/studio/server/services/emailRenderer.ts` for template rendering
- Implemented `renderTemplate(db, templateId, variables)` - fetches template from DB and renders to HTML/text
- Implemented `renderComponents(components, variables, previewText)` - renders components directly for previews
- Implemented `interpolateProps()` for recursive variable interpolation in string props
- Handles `{{variableName}}` syntax and replaces with variable values
- Missing variables replaced with empty string (graceful fallback)
- Uses @react-email/render to convert React components to HTML string
- Uses Html, Body, Container, Head, Preview components from @react-email for email structure
- Build passes (pre-existing typecheck error in Login.tsx not related)

**Files changed:**

- `apps/studio/server/email-components/index.ts` (created)
- `apps/studio/server/services/emailRenderer.ts` (created)
- `backlog/backlog.json` (updated US-018 passes status)

**Learnings for future iterations:**

- Component registry uses `AnyComponent = React.ComponentType<any>` to avoid strict type conflicts
- Schema types need `as unknown as ComponentSchema` cast from const assertions
- React.createElement requires `any` cast for props when using dynamic component types
- Variable interpolation should be recursive to handle nested objects and arrays
- @react-email/render accepts `{plainText: true}` option for text-only output
- D1Database type comes from `@cloudflare/workers-types`

### Iteration: 2026-01-20 (continued)

**Story:** US-019 - Seed default components into database
**Status:** Complete

**What was done:**

- Created `apps/studio/server/db/seed-email-components.ts` for seeding email components
- Implemented `seedEmailComponents(db)` function that inserts all 7 components
- Function is idempotent - checks for existing components by type before inserting
- Stores schema and defaultProps as JSON strings in the database
- Imports schemas and defaultProps directly from email-components module
- Added `updateEmailComponents(db)` function for updating existing components when definitions change
- Added `getComponentTypesToSeed()` utility function for verification
- Build passes (pre-existing typecheck error in Login.tsx unrelated)

**Files changed:**

- `apps/studio/server/db/seed-email-components.ts` (created)
- `backlog/backlog.json` (updated US-019 passes status)

**Learnings for future iterations:**

- D1/Drizzle update() doesn't have reliable `rowsAffected` property - check for existence first
- Use `eq()` from drizzle-orm for where clause conditions
- Schema and defaultProps stored as `JSON.stringify()` in text columns
- Idempotent seed functions should check existence before insert, not rely on unique constraints
- Import from parent index.ts (../email-components) to get all exports cleanly

### Iteration: 2026-01-20 (continued)

**Story:** US-020 - Create template CRUD API routes
**Status:** Complete

**What was done:**

- Added 5 template CRUD endpoints to `apps/studio/server/routes/email.ts`
- `GET /api/email/templates` returns all templates (excluding archived by default, supports `includeArchived=true` query param)
- `GET /api/email/templates/:id` returns single template with parsed JSON components and variables
- `POST /api/email/templates` creates template with name, subject, empty components array
- `PATCH /api/email/templates/:id` updates template fields including components JSON, variables, status
- `DELETE /api/email/templates/:id` soft-deletes by setting status to 'archived'
- Added 'archived' to emailTemplates status enum in schema.ts
- All template routes require authentication via authMiddleware

**Files changed:**

- `apps/studio/server/routes/email.ts` (modified - added ~170 lines for template CRUD)
- `apps/studio/server/db/schema.ts` (modified - added 'archived' to status enum)
- `backlog/backlog.json` (updated US-020 passes status)

**Learnings for future iterations:**

- SQLite stores text columns without enum constraints, so adding new enum values works without migration
- Drizzle schema enum changes only need TypeScript update, not database migration
- List endpoints should exclude soft-deleted items by default with optional query param to include them
- JSON fields stored as text need `JSON.parse()` when returning to client, `JSON.stringify()` when saving
- Use `or()` helper to filter for multiple status values in where clause

### Iteration: 2026-01-20 (continued)

**Story:** US-021 - Add template preview endpoint
**Status:** Complete

**What was done:**

- Added POST /api/email/templates/:id/preview endpoint to apps/studio/server/routes/email.ts
- Accepts optional `variables` object in request body for interpolation
- Uses existing `renderTemplate` and `getDefaultVariables` from emailRenderer service
- Returns JSON response with html, text, and merged variables (defaults + provided)
- Handles errors gracefully with appropriate error messages
- Build passes successfully

**Files changed:**

- `apps/studio/server/routes/email.ts` (modified - added ~55 lines for preview endpoint)
- `backlog/backlog.json` (updated US-021 passes status)

**Learnings for future iterations:**

- Zod schema can be made optional by wrapping in `.optional()` to allow empty request bodies
- `renderTemplate` function from emailRenderer already handles all rendering logic including variable interpolation
- `getDefaultVariables` export useful for returning the full variable context to clients
- Preview endpoints should return both rendered output AND the variables used for transparency

### Iteration: 2026-01-20 (continued)

**Story:** US-022 - Add send test email endpoint
**Status:** Complete

**What was done:**

- Added POST /api/email/templates/:id/test endpoint to apps/studio/server/routes/email.ts
- Requires `to` email address in request body (validated with Zod email schema)
- Subject prefixed with "[TEST] " for clear identification in inbox
- Uses existing `renderTemplate` and `getDefaultVariables` for sample variable interpolation
- Returns Resend message ID on success plus remaining test emails count
- Implemented rate limiting at 10 test emails per hour per authenticated user
- Rate limiting uses in-memory Map tracking userEmail -> {count, windowStart}
- Sends via existing Resend integration with dynamic import
- Build passes successfully

**Files changed:**

- `apps/studio/server/routes/email.ts` (modified - added ~126 lines for test endpoint and rate limiting)
- `backlog/backlog.json` (updated US-022 passes status)

**Learnings for future iterations:**

- Rate limiting can use Map with sliding window pattern: track count and windowStart per user
- Return `remainingTestEmails` count to help users understand their quota
- Dynamic `import('resend')` works well for on-demand module loading in routes
- Resend `emails.send()` returns `{data: {id}, error}` - check error first before accessing data
- Authenticated user available via `c.get('user')` in Hono routes with auth middleware

### Iteration: 2026-01-20 (continued)

**Story:** US-023 - Create template list page UI
**Status:** Complete

**What was done:**

- Created `apps/studio/client/pages/email/Templates.tsx` with full template list UI
- Implemented responsive grid layout for template cards (1/2/3 columns based on breakpoint)
- Added TemplateCard component showing name, subject preview, last modified date
- Implemented StatusBadge component with Draft (gray), Active (green), Archived (red) states
- Created EmptyState component with email icon and call-to-action button
- Added template API methods to `apps/studio/client/lib/api.ts`:
  - list, get, create, update, delete, preview, sendTest
- Registered `/email/templates` route in `apps/studio/client/App.tsx`
- Click on template card navigates to editor (using react-router-dom useNavigate)
- Verified in browser using chrome-devtools MCP

**Files changed:**

- `apps/studio/client/pages/email/Templates.tsx` (created)
- `apps/studio/client/lib/api.ts` (modified - added template API methods)
- `apps/studio/client/App.tsx` (modified - added route and import)
- `backlog/backlog.json` (updated US-023 passes status)

**Learnings for future iterations:**

- Template list uses grid layout pattern: `grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4`
- Button components can use `onClick` with `navigate()` from useNavigate hook
- Empty states should have both descriptive text and call-to-action button
- StatusBadge component can be shared between Templates and Campaigns pages (similar pattern)
- API types should match backend response structure exactly for TypeScript inference

### Iteration: 2026-01-20 (continued)

**Story:** US-024 - Create template editor page layout
**Status:** Complete

**What was done:**

- Created `apps/studio/client/pages/email/Editor.tsx` with three-panel layout
- Left panel: Component Library showing all 7 email component types with icons and descriptions
- Center panel: Canvas with empty state and component display (click-to-add functionality)
- Right panel: Properties panel placeholder for selected component editing
- Toolbar: Back arrow, editable template name input, Preview, Send Test, and Save buttons
- Subject line and preview text inputs above the canvas area
- Mobile responsive warning banner shown on screens < md breakpoint
- Preview modal with desktop/mobile width toggle
- Test email modal with email input and success/error states
- Registered routes for `/email/templates/new` and `/email/templates/:id`

**Files changed:**

- `apps/studio/client/pages/email/Editor.tsx` (created)
- `apps/studio/client/App.tsx` (modified - added routes and import)
- `backlog/backlog.json` (updated US-024 passes status)

**Learnings for future iterations:**

- Three-panel layout pattern: `hidden md:block` for side panels, `flex-1` for center panel
- Mobile warning uses yellow theme: `bg-yellow-500/10` with `text-yellow-800 dark:text-yellow-200`
- Component instances need unique IDs - use `${type}-${Date.now()}` pattern
- useQuery with `enabled: false` prevents fetching when condition not met (e.g., new template)
- Editor state management: separate state for each editable field, track `hasUnsavedChanges`
- Modal pattern: fixed inset-0 z-50 with bg-black/50 backdrop
- Form inputs use consistent styling: `rounded-md border border-border bg-card px-3 py-2`

### Iteration: 2026-01-20 (continued)

**Story:** US-025 - Implement component library panel in editor
**Status:** Complete

**What was done:**

- Installed @dnd-kit/core, @dnd-kit/sortable, @dnd-kit/utilities for drag-and-drop functionality
- Added DndContext wrapper with PointerSensor (8px activation distance to prevent accidental drags)
- Created DraggableComponentItem using useDraggable hook for library components
- Created CanvasDropZone using useDroppable hook as drop target
- Grouped components by category (Layout: Header, Divider, Footer; Content: Hero, TextBlock, CallToAction, ProductGrid)
- Added DragOverlay for ghost preview showing component card with primary accent colors during drag
- Updated EmptyCanvasState to show visual feedback when dragging (dashed border, "Drop component here" message)
- Canvas shows ring and background color change when dragging over it

**Files changed:**

- `apps/studio/client/pages/email/Editor.tsx` (modified - ~260 lines added/changed)
- `apps/studio/package.json` (modified - added @dnd-kit dependencies)
- `pnpm-lock.yaml` (updated)
- `backlog/backlog.json` (updated US-025 passes status)

**Learnings for future iterations:**

- @dnd-kit/core provides DndContext, useDraggable, useDroppable, DragOverlay as core primitives
- PointerSensor with `activationConstraint: {distance: 8}` prevents accidental drag starts
- useDraggable returns `{attributes, listeners, setNodeRef, isDragging}` - spread attributes/listeners on element
- useDroppable returns `{setNodeRef, isOver}` for drop target state
- DragOverlay renders outside normal DOM flow for smooth dragging (no layout shift)
- Track activeDragType in state to show appropriate feedback during drag operations
- Components can be both clickable (onClick for add) and draggable (listeners for drag)

### Iteration: 2026-01-20 (continued)

**Story:** US-026 - Implement canvas panel with sortable components
**Status:** Complete

**What was done:**

- Added @dnd-kit/sortable integration for component reordering in canvas
- Created SortableCanvasComponent using useSortable hook from @dnd-kit/sortable
- Added drag handle (GripVerticalIcon) visible on hover for each canvas component
- Implemented dual drag modes: library drag (add new) and canvas drag (reorder)
- Used SortableContext with verticalListSortingStrategy for smooth reordering
- Used arrayMove from @dnd-kit/sortable for state updates after reorder
- Added CSS.Transform for smooth drag animations
- Updated API types in api.ts to include component `id` field
- Handle legacy components without IDs when loading templates (generate IDs on load)
- Visual feedback during drag: opacity change, border highlight

**Files changed:**

- `apps/studio/client/pages/email/Editor.tsx` (modified - ~180 lines added/changed)
- `apps/studio/client/lib/api.ts` (modified - updated template component type)
- `backlog/backlog.json` (updated US-026 passes status)

**Learnings for future iterations:**

- @dnd-kit/sortable provides SortableContext, useSortable, and arrayMove for sortable lists
- useSortable returns `{attributes, listeners, setNodeRef, transform, transition, isDragging}`
- CSS.Transform.toString() converts transform to CSS string for smooth animations
- Track `isDraggingFromLibrary` to differentiate between adding new components and reordering
- Drag handles should use separate listeners from the container (onClick for select, listeners for drag)
- When checking drag source, use String(active.id).startsWith() to identify library vs canvas drags
- Component IDs should be generated on load if missing (for legacy data compatibility)

### Iteration: 2026-01-20 (continued)

**Story:** US-027 - Implement properties panel in editor
**Status:** Complete

**What was done:**

- Added COMPONENT_SCHEMAS constant with all 7 email component schema definitions client-side
- Implemented PropertiesPanel component that dynamically generates form fields from schema
- Supported input types: string (text input), textarea (multiline), color (color picker + hex input), select (dropdown), number
- Implemented array type support with add/remove item functionality (for products, socialLinks)
- Added variable hints for text fields showing "Tip: Use {{firstName}} for personalization"
- Real-time updates: changes to properties immediately update component state
- Shows "Select a component to edit its properties" when no component selected
- Schema includes label, description, required flag, default values, and options for select fields

**Files changed:**

- `apps/studio/client/pages/email/Editor.tsx` (modified - ~600 lines added)
- `backlog/backlog.json` (updated US-027 passes status)

**Learnings for future iterations:**

- Component schemas can be duplicated client-side to avoid server imports (simpler than shared package)
- Array type handling: use itemSchema to define fields for each array item
- Select values may be strings or numbers - use `String(option.value)` for option key and value attr
- For array items with select defaults, use first option value: `fieldSchema.options[0].value`
- Color picker input type="color" combined with text input provides both visual and hex editing
- Variable hints should be contextual - show for fields where personalization makes sense (text, headlines, content)

### Iteration: 2026-01-20 US-028

**Story:** US-028 - Implement template save functionality
**Status:** Complete

**What was done:**

- Added auto-save after 5 seconds of inactivity using debounced setTimeout
- Added save indicator showing "Saving..." during request
- Added save indicator showing "Saved" with timestamp on success
- Added error toast on save failure with auto-dismiss after 5 seconds
- Added unsaved changes warning modal when navigating away via back button
- Added beforeunload handler for browser tab close/refresh warning
- Used state-based navigation warning instead of useBlocker (which requires data router)

**Files changed:**

- apps/studio/client/pages/email/Editor.tsx

**Learnings for future iterations:**

- useBlocker hook requires createBrowserRouter (data router), not BrowserRouter - use state-based modal instead
- Auto-save should use a ref for the timeout to properly clear on component unmount
- isInitialLoadRef pattern prevents triggering auto-save on initial data load
- beforeunload event handler is browser-native way to warn on tab close
- For navigation warnings without data router, track pendingNavigation in state and show modal

### Iteration: 2026-01-20 US-029

**Story:** US-029 - Implement preview modal in editor
**Status:** Complete

**What was done:**

- Enhanced PreviewModal component with full functionality
- Added escape key handler using useEffect with keydown event listener
- Added backdrop click handler to close modal when clicking outside
- Prevent background scrolling when modal is open via document.body.style.overflow
- Pass sample variables (firstName: "Friend") to preview API for interpolation
- Added desktop/mobile toggle with icons (DesktopIcon, MobileIcon)
- Added proper error states when preview fails
- Added loading state with spinner during preview generation
- Display "Save template first" message for unsaved templates (templateId null)
- Show width indicator (600px/375px) and sample variable info in modal footer

**Files changed:**

- apps/studio/client/pages/email/Editor.tsx (modified - ~150 lines added, PreviewModal enhanced, added DesktopIcon and MobileIcon)

**Learnings for future iterations:**

- useEffect for keyboard events: add listener in effect, cleanup in return function
- Escape key detection: check event.key === 'Escape'
- Backdrop click: check e.target === e.currentTarget on the overlay div
- Prevent body scroll: set document.body.style.overflow = 'hidden', restore to '' in cleanup
- Modal accessibility: close on escape is expected UX behavior
- Width toggle buttons: use active state styling to show current selection
- Preview API accepts optional variables object for template interpolation

### Iteration: 2026-01-20 US-030

**Story:** US-030 - Implement send test modal in editor
**Status:** Complete

**What was done:**

- Enhanced TestEmailModal component with full functionality
- Added useAuth hook integration to pre-fill email with user's email address
- Added escape key handler using useEffect with keydown event listener
- Added backdrop click handler to close modal when clicking outside content
- Prevent background scrolling when modal is open via document.body.style.overflow
- Added description text explaining the modal purpose ("Send a test email to preview...")
- Enhanced loading state with spinner animation in the button
- Improved error display with styled alert box (red border, icon, background)
- Added autoFocus on email input for better UX
- Added "Close (Esc)" title to close button for accessibility
- Fixed pre-existing TypeScript error in Login.tsx (data typed as unknown)

**Files changed:**

- apps/studio/client/pages/email/Editor.tsx (modified - added useAuth import, enhanced TestEmailModal ~50 lines added)
- apps/studio/client/pages/Login.tsx (modified - fixed TypeScript error with type assertion)

**Learnings for future iterations:**

- useAuth hook provides user object with email property for pre-filling forms
- Re-use modal patterns from PreviewModal: escape key, backdrop click, body scroll prevention
- Loading spinner in buttons: use nested span with animate-spin class on a border element
- Error display: styled alert box with icon is better UX than plain text
- autoFocus attribute on input makes modal more accessible
- Type assertion `as {error?: string}` fixes unknown type from JSON parsing

### Iteration: 2026-01-20 US-031

**Story:** US-031 - Create AI template generation service
**Status:** Complete

**What was done:**

- Created `apps/studio/server/services/email-ai.ts` for AI-powered template generation
- Implemented `generateTemplate(apiKey, prompt, brandContext)` function using Gemini AI
- Created comprehensive system prompt enforcing Wakey brand voice:
  - Cheeky, not childish; Warm, not soft; Real, not raw
  - Never use emojis or exclamation marks
  - Brand colors: #1a1a1a (black), #FFF5EB (sand), #FAD103 (softorange/yellow)
- Implemented `formatComponentSchemas()` to include all 7 component schemas in AI prompt
- Implemented `validateComponents()` to validate AI output against schemas
- Auto-fixes missing component IDs and merges with default props
- Falls back to basic template via `generateFallbackTemplate()` if AI fails
- Returns `GeneratedTemplate` with components, suggestedSubject, suggestedPreviewText

**Files changed:**

- apps/studio/server/services/email-ai.ts (created - 379 lines)

**Learnings for future iterations:**

- Gemini response can be wrapped in markdown code blocks - extract JSON with regex
- Component validation should be lenient: auto-fix IDs, merge with defaults
- Always provide a fallback template when AI generation fails
- Brand voice guidelines should be explicit in the system prompt (what NOT to do is as important as what to do)
- Use `isValidComponentType()` type guard from component registry for validation

### Iteration: 2026-01-20 US-032

**Story:** US-032 - Add AI generation endpoint
**Status:** Complete

**What was done:**

- Added `POST /api/email/templates/generate` endpoint to apps/studio/server/routes/email.ts
- Accepts `prompt` in request body (validated with Zod, min 10 chars)
- Implemented rate limiting at 20 generations per day per user
- Uses in-memory Map tracking userEmail -> {count, windowStart}
- Logs all generation requests for monitoring
- Returns generated template with components, suggestedSubject, suggestedPreviewText
- Returns remainingGenerations in response to help users track quota

**Files changed:**

- apps/studio/server/routes/email.ts (modified - added ~112 lines)

**Learnings for future iterations:**

- Reuse rate limiting pattern from test email endpoint (Map with sliding window)
- Daily rate limit uses 24 * 60 * 60 * 1000 for oneDay constant
- Dynamic import `await import('../services/email-ai')` for on-demand module loading
- Log user email and prompt snippet for monitoring (truncate to 50 chars for privacy/brevity)

### Iteration: 2026-01-20 US-033

**Story:** US-033 - Add AI generation UI to template editor
**Status:** Complete

**What was done:**

- Added `api.email.templates.generate(prompt)` method to client api.ts
- Added "Generate with AI" button to editor toolbar with yellow accent styling and SparklesIcon
- Updated EmptyCanvasState to show "Generate with AI" as primary CTA instead of "Add Hero Component"
- Created AIGenerateModal component with:
  - Textarea for prompt input (min 10 chars)
  - 5 example prompt buttons (Welcome, Product launch, Newsletter, Thank you, Checkout)
  - Loading state with animated spinner
  - Confirmation dialog when hasExistingComponents is true
  - Escape key and backdrop click to close
  - Body scroll prevention when open
- Added SparklesIcon component (SVG with stars pattern)
- Updated CanvasDropZone to accept onGenerateWithAI prop
- Verified in browser: modal opens, example prompts fill textarea, Generate button enables

**Files changed:**

- apps/studio/client/lib/api.ts (modified - added generate method)
- apps/studio/client/pages/email/Editor.tsx (modified - added ~310 lines)

**Learnings for future iterations:**

- Follow existing modal patterns: escape key, backdrop click, body overflow hidden
- Example prompts as clickable buttons improve UX for AI features
- Confirmation dialog for destructive actions (replacing existing content)
- Yellow accent styling for AI-related buttons makes them stand out
- SparklesIcon is a good visual indicator for AI features

### Iteration: 2026-01-20 US-034

**Story:** US-034 - Create campaign CRUD API routes
**Status:** Complete

**What was done:**

- Added GET /api/email/campaigns - list all campaigns with send stats
- Added GET /api/email/campaigns/:id - get single campaign with template, segments, stats
- Added POST /api/email/campaigns - create campaign (validates template/segments exist)
- Added PATCH /api/email/campaigns/:id - update draft campaigns only
- Added DELETE /api/email/campaigns/:id - delete draft campaigns only
- Used segmentIds as JSON array field (campaigns.segmentIds stores JSON string)
- Calculate send stats using SQL aggregation: total, sent, delivered, opened, clicked, bounced

**Files changed:**

- apps/studio/server/routes/email.ts (modified - added ~314 lines)

**Learnings for future iterations:**

- Check schema carefully: field was `segmentIds` (plural) as JSON array, not `segmentId` (singular)
- templateId can be null, need to handle with if check before querying
- Use `inArray()` from drizzle-orm for validating multiple IDs exist
- JSON.stringify/JSON.parse for converting between JS array and text column
- For PATCH with JSON array fields, handle undefined vs null: undefined = don't change, null = clear it
- SQL aggregation with CASE WHEN for counting statuses is more efficient than multiple queries

### Iteration: 2026-01-20 US-035

**Story:** US-035 - Create campaigns list page UI
**Status:** Complete

**What was done:**

- Created `apps/studio/client/pages/email/Campaigns.tsx` with full campaign list UI
- Implemented table with columns: Name (with subject), Status, Sent Date, Open Rate, Click Rate
- Added status filter dropdown (All, Draft, Scheduled, Sending, Sent, Cancelled)
- Implemented StatusBadge component with color-coded badges:
  - Draft: gray (bg-muted)
  - Scheduled: blue (bg-blue-500/20) with countdown display
  - Sending: yellow (bg-yellow-500/20)
  - Sent: green (bg-green-500/20)
  - Cancelled: red (bg-red-500/20)
- Added "Create Campaign" button in header
- Clickable rows navigate to campaign detail/editor (/email/campaigns/:id)
- Empty state with call-to-action button
- Added campaign API methods to `apps/studio/client/lib/api.ts`:
  - list, get, create, update, delete
- Registered `/email/campaigns` route in `apps/studio/client/App.tsx`
- Added auth middleware for campaign routes in `apps/studio/server/routes/email.ts`
- Open rate and click rate calculated from stats (delivered as denominator)

**Files changed:**

- apps/studio/client/pages/email/Campaigns.tsx (created)
- apps/studio/client/lib/api.ts (modified - added campaigns API methods)
- apps/studio/client/App.tsx (modified - added route and import)
- apps/studio/server/routes/email.ts (modified - added campaigns auth middleware)

**Learnings for future iterations:**

- Campaign routes need explicit auth middleware like other email routes: `emailRoutes.use('/campaigns/*', authMiddleware)` and `emailRoutes.use('/campaigns', authMiddleware)`
- StatusBadge can show additional context (like scheduled time countdown) for specific statuses
- Open/click rates should use delivered count as denominator, not total sent
- formatScheduledTime helper useful for showing relative time for scheduled campaigns
- Table rows can be clickable with cursor-pointer and onClick handlers

### Iteration: 2026-01-20 US-036

**Story:** US-036 - Create campaign editor page
**Status:** Complete

**What was done:**

- Created `apps/studio/client/pages/email/CampaignEditor.tsx` for campaign creation/editing
- Implemented form fields: Campaign Name, Subject Line, Preview Text (optional)
- Added template selector dropdown showing active/draft templates
- Added "Create a template" link when no templates available
- Implemented segment multi-select with checkbox UI for recipient targeting
- Shows estimated recipient count based on selected segments
- Added preview modal to view template with sample data (desktop/mobile toggle)
- Implemented Save as Draft functionality with create/update mutations
- Handle non-editable campaigns (sent/scheduled) with redirect to details page
- Added segments list API method to `apps/studio/client/lib/api.ts`
- Registered `/email/campaigns/new` and `/email/campaigns/:id/edit` routes in App.tsx

**Files changed:**

- apps/studio/client/pages/email/CampaignEditor.tsx (created)
- apps/studio/client/lib/api.ts (modified - added segments.list API method)
- apps/studio/client/App.tsx (modified - added CampaignEditor routes)

**Learnings for future iterations:**

- Reuse PreviewModal pattern from template Editor for consistent preview experience
- Segment selection uses checkbox UI with label wrapper for better click target
- Estimated recipients calculation is approximate - actual count requires server-side deduplication
- Non-editable campaigns (status !== 'draft') should redirect to detail view
- Campaign GET response includes segmentIds as JSON string - need JSON.parse() to convert to array

### Iteration: 2026-01-20 US-037

**Story:** US-037 - Implement campaign scheduling
**Status:** Complete

**What was done:**

- Added schedule UI to CampaignEditor with Send Now / Schedule for Later radio buttons
- Implemented date/time picker that appears when Schedule for Later is selected
- Added 15-minute minimum constraint for scheduled time validation
- Display user's timezone using Intl.DateTimeFormat().resolvedOptions().timeZone
- Added POST /api/email/campaigns/:id/schedule endpoint to schedule or send immediately
- Added POST /api/email/campaigns/:id/cancel endpoint to cancel scheduled campaigns
- Updated non-editable campaign view to show cancel button for scheduled campaigns
- Added schedule and cancel API methods to client api.ts
- "Send Now" sets campaign to scheduled status with current time (cron will pick up)
- "Schedule for Later" validates and sets scheduledAt timestamp

**Files changed:**

- apps/studio/client/pages/email/CampaignEditor.tsx (modified - added ~250 lines)
- apps/studio/client/lib/api.ts (modified - added schedule and cancel methods)
- apps/studio/server/routes/email.ts (modified - added schedule and cancel endpoints)

**Learnings for future iterations:**

- Intl.DateTimeFormat().resolvedOptions().timeZone provides user's local timezone
- Date validation: compare Date objects directly using >= operator
- For "Send Now" functionality, set scheduledAt to current time and let cron job process
- Cancel endpoint should only work on scheduled campaigns, returning them to draft status
- getMinDate() and getMinTime() need to handle date boundaries (min time only applies for today)
- Use confirm() dialog for destructive actions like cancelling a scheduled campaign

### Iteration: 2026-01-20 US-038

**Story:** US-038 - Implement campaign sending service
**Status:** Complete

**What was done:**

- Created `apps/studio/server/services/campaignSender.ts`
- Implemented `sendCampaign(db, resendApiKey, campaignId, fromEmail)` function
- Fetch subscribers from segments via segmentSubscribers join, with deduplication using Set
- Filter to active subscribers only (status === 'active')
- Render templates with subscriber-specific variables (firstName, lastName, email)
- Send via Resend batch API with BATCH_SIZE = 100
- Implemented exponential backoff retry for rate limiting (MAX_RETRIES = 3)
- Create email_sends record for each recipient with resendId for tracking
- Update campaign status: scheduled -> sending -> sent
- Handle errors with graceful rollback to draft status

**Files changed:**

- apps/studio/server/services/campaignSender.ts (created - 435 lines)

**Learnings for future iterations:**

- Resend batch.send() returns nested data: result.data.data contains the array of {id} objects
- Use Set for efficient deduplication when subscribers may be in multiple segments
- Batch processing with delay between batches respects API rate limits
- Log batch progress for visibility during long campaign sends
- On critical failure, roll back campaign status to draft so it can be retried
- Sleep function using Promise with setTimeout for async delay

### Iteration: 2026-01-20 US-039

**Story:** US-039 - Add send now endpoint
**Status:** Complete

**What was done:**

- Added `POST /api/email/campaigns/:id/send` endpoint to email.ts
- Validates campaign is in draft status before sending
- Validates template and segments are properly configured
- Updates campaign status to 'scheduled' with current timestamp
- Triggers sendCampaign service asynchronously via waitUntil
- Returns immediately with "Campaign sending started" message and campaign info
- Dynamic import of campaignSender service for code splitting

**Files changed:**

- apps/studio/server/routes/email.ts (modified - added ~97 lines)

**Learnings for future iterations:**

- waitUntil allows background processing while returning response immediately
- Dynamic import() useful for loading heavy services only when needed
- Return campaign ID and name in response for client tracking
- Separate /send endpoint from /schedule provides clearer API semantics

### Iteration: 2026-01-20 US-040

**Story:** US-040 - Implement cron job for scheduled campaigns
**Status:** Complete

**What was done:**

- Added `*/5 * * * *` cron trigger to wrangler.jsonc (every 5 minutes)
- Created `apps/studio/server/services/scheduledCampaigns.ts` with processScheduledCampaigns()
- Query finds campaigns where status='scheduled' AND scheduledAt <= now
- Process each campaign using existing sendCampaign service
- Updated index.ts scheduled handler to dispatch based on event.cron pattern
- Daily keyword check (0 6 * * *) and campaign processing (*/5 * * * *) run separately
- Logs found, processed, and failed counts for monitoring

**Files changed:**

- apps/studio/wrangler.jsonc (modified - added cron trigger)
- apps/studio/server/index.ts (modified - updated scheduled handler)
- apps/studio/server/services/scheduledCampaigns.ts (created - 88 lines)

**Learnings for future iterations:**

- Cloudflare Workers cron triggers configured in wrangler.jsonc under triggers.crons
- event.cron string matches the cron pattern for dispatching different handlers
- lte() from drizzle-orm for "less than or equal" comparisons
- Process campaigns sequentially to avoid overwhelming Resend API
- Log counts (found/processed/failed) for operational visibility


### Iteration: 2026-01-20 US-041

**Story:** US-041 - Create campaign detail/analytics page
**Status:** Complete

**What was done:**

- Created `apps/studio/client/pages/email/CampaignDetail.tsx` with full campaign analytics UI
- Shows campaign name, subject, status badge, template, segments, sent date, created date
- Implemented 6 stats cards: Sent, Delivered, Opened, Clicked, Bounced, Unsubscribed
- Stats show counts and percentage rates (open rate, click rate, bounce rate, delivery rate)
- Color coding: green for good metrics, red for warnings (high bounce rate)
- Added paginated recipients table with columns: Email, Name, Status, Sent, Opened, Clicked
- SendStatusBadge component shows recipient status (pending/sent/delivered/opened/clicked/bounced/complained)
- Added `GET /api/email/campaigns/:id/recipients` endpoint with pagination
- Added `api.email.campaigns.recipients(id, page, limit)` client API method
- Registered route `/email/campaigns/:id` in App.tsx

**Files changed:**

- apps/studio/client/pages/email/CampaignDetail.tsx (created - 370 lines)
- apps/studio/server/routes/email.ts (modified - added ~60 lines for recipients endpoint)
- apps/studio/client/lib/api.ts (modified - added recipients method)
- apps/studio/client/App.tsx (modified - added CampaignDetail import and route)

**Learnings for future iterations:**

- Stats cards can use highlight (green) and warning (red) props for visual feedback
- Recipients endpoint joins emailSends with subscribers to get subscriber details
- Pagination component can be shared pattern: Previous/Next buttons with page/totalPages display
- SendStatus has 7 possible states vs CampaignStatus which has 5
- Browser verification blocked by unrelated dependency issue in different workspace

### Iteration: 2026-01-20 US-042

**Story:** US-042 - Add Resend webhook handler for email events
**Status:** Complete (Already Implemented)

**What was done:**

- Verified that US-042 was already implemented in previous iteration
- Resend webhook handler at `POST /api/email/webhooks/resend` (lines 310-603 in email.ts)
- SVix signature verification implemented (RESEND_WEBHOOK_SECRET env var)
- Handles all required events: email.sent, email.delivered, email.opened, email.clicked, email.bounced, email.complained
- Updates `email_sends` record status and timestamps (sentAt, deliveredAt, openedAt, clickedAt)
- For bounced: marks subscriber status as 'bounced'
- For complained: marks subscriber status as 'complained'
- Returns 200 OK quickly to prevent retries
- Build and typecheck pass

**Files changed:**

- backlog/backlog.json (updated US-042 passes status)
- backlog/progress.txt (updated with this entry)

**Learnings for future iterations:**

- Resend uses SVix for webhook signing (not a simple HMAC like Shopify)
- SVix signature format: `v1,base64signature` - may have multiple signatures separated by space
- Timestamp validation prevents replay attacks (5 minute window)
- The 'complained' status was already added to schema enum in previous iteration
- Always check existing code before implementing - US-042 was complete but not marked

### Iteration: 2026-01-20 US-043 & US-044

**Story:** US-043 - Add click tracking to email links
**Story:** US-044 - Add open tracking pixel to emails
**Status:** Complete (Both implemented together)

**What was done:**

- Created `apps/studio/server/services/emailTracking.ts` with tracking functions:
  - `addClickTracking(html, options)` - wraps all href links with tracking redirects
  - `addOpenTrackingPixel(html, baseUrl, emailSendId)` - appends 1x1 transparent GIF
  - `applyEmailTracking(html, options)` - applies both click and open tracking
  - `addUtmParameters(url, campaignId)` - adds utm_source, utm_medium, utm_campaign
- Added `GET /api/email/track/click` endpoint to email.ts:
  - Validates emailSendId parameter
  - Records click event in email_events table
  - Updates email_sends.clickedAt if first click
  - Redirects to target URL (already has UTM params from tracking service)
- Added `GET /api/email/track/open` endpoint to email.ts:
  - Returns 1x1 transparent GIF (42 bytes)
  - Records open event in email_events table
  - Updates email_sends.openedAt if first open
  - Preserves 'clicked' status (doesn't downgrade)
- Modified campaignSender.ts to integrate tracking:
  - Creates email_sends records FIRST to get IDs for tracking
  - Applies tracking after template rendering
  - Updates records with resendId after sending
- Tracking URLs format: `https://studio.wakey.care/api/email/track/click?eid={id}&url={encodedUrl}`
- Open pixel format: `https://studio.wakey.care/api/email/track/open?eid={id}`

**Files changed:**

- apps/studio/server/services/emailTracking.ts (created - 109 lines)
- apps/studio/server/routes/email.ts (modified - added ~140 lines for tracking endpoints)
- apps/studio/server/services/campaignSender.ts (modified - refactored batch processing)
- backlog/backlog.json (updated US-043 and US-044 passes status)

**Learnings for future iterations:**

- Tracking requires emailSendId, so must create email_sends record BEFORE sending
- Flow: create record -> get ID -> apply tracking -> send email -> update with resendId
- 1x1 transparent GIF is 42 bytes (smallest valid GIF)
- Skip tracking for unsubscribe links, mailto:, tel:, and # hrefs
- Use Cache-Control: no-store headers on tracking pixel to prevent caching
- Repeat clicks/opens should still log to email_events but not update first timestamp

### Iteration: 2026-01-20 US-045

**Story:** US-045 - Create unsubscribe token generation utility
**Status:** Complete

**What was done:**

- Created `apps/studio/server/utils/unsubscribe.ts` with:
  - `generateUnsubscribeToken(subscriberId, secret)` - creates signed token
  - `verifyUnsubscribeToken(token, secret)` - validates and returns subscriberId
  - `generateUnsubscribeUrl(baseUrl, subscriberId, secret)` - full URL helper
- Token format: `base64(payload).base64(signature)` (similar to JWT but simplified)
- Payload includes: `subscriberId`, `iat` (issued at timestamp)
- Uses HMAC-SHA256 signing via Web Crypto API (native to CF Workers)
- Tokens expire after 1 year (365 days)
- URL-safe base64 encoding (replaces +/= with -/_)
- Validates signature, payload structure, and expiration

**Files changed:**

- apps/studio/server/utils/unsubscribe.ts (created - 145 lines)
- backlog/backlog.json (updated US-045 passes status)

**Learnings for future iterations:**

- Web Crypto API is available in Cloudflare Workers (no external JWT library needed)
- Use URL-safe base64 (replace +/= with -/_) for tokens in URLs
- Token format is simpler than JWT but provides same security guarantees
- Separate signature verification from payload parsing for clear error messages

### Iteration: 2026-01-20 US-046

**Story:** US-046 - Create unsubscribe page and API
**Status:** Complete

**What was done:**

- Created `apps/studio/client/pages/Unsubscribe.tsx` - public-facing unsubscribe page
  - Shows loading/error/success states
  - Displays masked email (j***@example.com)
  - Confirm unsubscribe button
  - noscript fallback for accessibility (works without JavaScript)
- Added `GET /api/email/unsubscribe` endpoint - validates token, returns subscriber info
- Added `POST /api/email/unsubscribe` endpoint - processes unsubscribe request
- Updated `sendCampaign()` to accept `authSecret` and generate unsubscribe URLs
- Updated `processScheduledCampaigns()` to pass `authSecret`
- Updated cron handler and send now route to pass `AUTH_SECRET`
- Records unsubscribe event in `email_events` table
- Route registered at `/unsubscribe` (outside ProtectedRoute)

**Files changed:**

- apps/studio/client/pages/Unsubscribe.tsx (created - 210 lines)
- apps/studio/client/App.tsx (modified - added Unsubscribe import and route)
- apps/studio/server/routes/email.ts (modified - added unsubscribe endpoints)
- apps/studio/server/services/campaignSender.ts (modified - added authSecret param, generate unsubscribeUrl)
- apps/studio/server/services/scheduledCampaigns.ts (modified - added authSecret param)
- apps/studio/server/index.ts (modified - pass AUTH_SECRET to processScheduledCampaigns)
- backlog/backlog.json (updated US-046 passes status)

**Learnings for future iterations:**

- Public pages (unsubscribe) must be outside ProtectedRoute in App.tsx
- Token can be sent via query string, JSON body, or form-urlencoded body
- Mask email for privacy: show first char + *** + @ + domain
- Record event with previous status for audit trail
- noscript fallback ensures accessibility even without JS

### Iteration: 2026-01-20 US-047

**Story:** US-047 - Add List-Unsubscribe header to sent emails
**Status:** Complete

**What was done:**

- Added `List-Unsubscribe` header to email sends in `campaignSender.ts`
- Header includes both mailto option (`mailto:unsubscribe@wakey.care?subject=unsubscribe-{id}`) and https option (unsubscribe URL with signed token)
- Added `List-Unsubscribe-Post: List-Unsubscribe=One-Click` header for RFC 8058 one-click unsubscribe support
- Headers only added when authSecret is provided and unsubscribeUrl is valid
- Footer component already includes unsubscribe link in email body (from US-016)
- Build and typecheck pass

**Files changed:**

- apps/studio/server/services/campaignSender.ts (modified - added headers support to batch email type, build headers conditionally)

**Learnings for future iterations:**

- List-Unsubscribe header format: `<mailto:...>, <https://...>` - both angle-bracket wrapped
- List-Unsubscribe-Post header value is exactly `List-Unsubscribe=One-Click` for RFC 8058
- Resend batch.send() accepts `headers` property in each email object
- Only include headers object in API call if it has properties (avoid empty object issues)

### Iteration: 2026-01-20 US-048

**Story:** US-048 - Create daily metrics aggregation service
**Status:** Complete

**What was done:**

- Created migration `0006_add_email_analytics.sql` with two new tables:
  - `daily_email_metrics`: stores sent, delivered, opened, clicked, bounced, unsubscribed per campaign per day
  - `daily_subscriber_metrics`: stores new subscribers, unsubscribed, net growth, total active per day
- Added Drizzle schema definitions for both tables in `schema.ts`
- Added proper relations and indexes for fast queries
- Created `apps/studio/server/services/analytics.ts` with:
  - `aggregateDailyMetrics(d1Database, date)` - main entry point
  - `aggregateEmailMetricsForCampaign()` - counts email send statuses
  - `aggregateSubscriberMetrics()` - counts subscriber changes
  - `upsertDailyEmailMetrics()` and `upsertDailySubscriberMetrics()` for idempotent updates
  - `getCampaignsWithSendsOnDate()` - finds campaigns that sent emails on a date
  - `getPreviousDay()` - utility for cron job usage
- Handles re-aggregation gracefully via upserts (check existence, update if exists, insert if not)
- Build and typecheck pass

**Files changed:**

- apps/studio/drizzle/migrations/0006_add_email_analytics.sql (created)
- apps/studio/server/db/schema.ts (modified - added dailyEmailMetrics, dailySubscriberMetrics tables and types)
- apps/studio/server/services/analytics.ts (created - 334 lines)

**Learnings for future iterations:**

- Use upsert pattern for aggregation: check existence first, then update or insert
- SQLite unique index on (date, campaign_id) enables fast lookups and prevents duplicates
- Subscriber metrics use email_events table to count unsubscribes (event_type = 'unsubscribe')
- Email metrics count from email_sends table using status field
- For "delivered", count statuses: delivered, opened, clicked (email was delivered if any of these)
- For "opened", count statuses: opened, clicked (email was opened if clicked)
- Date range queries use ISO format timestamps: `YYYY-MM-DDTHH:MM:SS.sssZ`

### Iteration: 2026-01-20 US-049

**Story:** US-049 - Add analytics aggregation to daily cron
**Status:** Complete

**What was done:**

- Added `0 2 * * *` cron trigger to wrangler.jsonc (2 AM UTC daily)
- Imported `aggregateDailyMetrics` and `getPreviousDay` from analytics service in index.ts
- Added cron handler for `0 2 * * *` that:
  - Gets the previous day's date using `getPreviousDay()`
  - Calls `aggregateDailyMetrics(env.DB, previousDay)`
  - Logs aggregation completion with email metrics count and subscriber changes
  - Handles errors gracefully with console.error
- Uses `ctx.waitUntil()` for async execution (same pattern as other cron handlers)
- Build and typecheck pass

**Files changed:**

- apps/studio/wrangler.jsonc (modified - added cron trigger)
- apps/studio/server/index.ts (modified - added import and cron handler)

**Learnings for future iterations:**

- Cron handler pattern: check `event.cron === 'pattern'` then `ctx.waitUntil(async IIFE)`
- Run analytics aggregation at 2 AM to ensure previous day's data is complete before aggregating
- `getPreviousDay()` utility function returns Date object for previous calendar day

### Iteration: 2026-01-20 US-050

**Story:** US-050 - Create analytics API endpoints
**Status:** Complete

**What was done:**

- Added `GET /api/email/analytics/overview` endpoint:
  - Returns total subscribers, active subscribers from subscribers table
  - Calculates 7-day growth rate from daily_subscriber_metrics
  - Gets 30-day email totals (sent, delivered, opened, clicked) from daily_email_metrics or raw data
  - Calculates avg open rate and click rate using delivered as denominator
- Added `GET /api/email/analytics/engagement` endpoint:
  - Accepts `period` query param: 7d, 30d (default), or 90d
  - Returns daily metrics from aggregated table (campaignId IS NULL for overall)
  - Calculates open/click rates per day
  - Falls back to raw email_sends data if no aggregated data
- Added `GET /api/email/analytics/campaigns` endpoint:
  - Returns recent sent/sending campaigns (configurable limit)
  - Gets metrics from aggregated table or raw email_sends
  - Calculates open rate, click rate, bounce rate for each campaign
- All endpoints use aggregated tables for performance with fallback to raw data
- Added auth middleware for analytics routes
- Build and typecheck pass

**Files changed:**

- apps/studio/server/routes/email.ts (modified - added ~310 lines for 3 analytics endpoints)
- backlog/backlog.json (updated US-050 passes status)

**Learnings for future iterations:**

- Analytics endpoints should use aggregated tables for performance (daily_email_metrics, daily_subscriber_metrics)
- Always provide fallback to raw data in case aggregation hasn't run yet
- Use delivered count as denominator for open/click rates (not sent)
- Growth rate calculation: (netGrowth / startingActive) * 100
- Aggregated data uses campaignId IS NULL for overall metrics
- Period params should be validated to known values (7d, 30d, 90d) with sensible default

### Iteration: 2026-01-20 US-051

**Story:** US-051 - Create email analytics dashboard page
**Status:** Complete

**What was done:**

- Created `apps/studio/client/pages/email/Dashboard.tsx` with:
  - Overview cards: Total Subscribers, Active Subscribers, Emails Sent (30d), Avg Open Rate, Avg Click Rate
  - Growth rate badge showing 7-day net growth percentage
  - SVG line chart for engagement over time (open/click rates)
  - Period selector dropdown (7d, 30d, 90d) that updates chart data
  - Campaign performance table with recent sent campaigns
  - All sections have loading states (spinners)
- Added analytics API methods to `client/lib/api.ts`:
  - `api.email.analytics.overview()` - fetches overview stats
  - `api.email.analytics.engagement(period)` - fetches daily engagement data
  - `api.email.analytics.campaigns(limit)` - fetches campaign performance
- Added routes to `App.tsx`:
  - `/email` redirects to `/email/dashboard`
  - `/email/dashboard` renders Dashboard page
- Build and typecheck pass
- Verified in browser using chrome-devtools MCP (page loads, shows auth loading state)

**Files changed:**

- apps/studio/client/pages/email/Dashboard.tsx (new)
- apps/studio/client/lib/api.ts (modified - added analytics methods)
- apps/studio/client/App.tsx (modified - added import and routes)
- backlog/backlog.json (updated US-051 passes status)

**Learnings for future iterations:**

- SVG line charts can be built without external libraries for simple use cases
- Chart scaling: find max value, use chartHeight / maxValue as scale factor
- Path generation: map data points to `M x y L x y L x y...` format
- For protected routes, verify loading state displays while auth check happens
- Use `useQuery` with different `queryKey` arrays to cache period-specific data

### Iteration: 2026-01-20 US-052

**Story:** US-052 - Add email routes to router configuration
**Status:** Complete

**What was done:**

- Verified all required routes are present in `apps/studio/client/App.tsx`:
  - `/email` â†’ redirects to `/email/dashboard`
  - `/email/dashboard` â†’ Dashboard page
  - `/email/subscribers` â†’ Subscribers page
  - `/email/templates` â†’ Templates list page
  - `/email/templates/new` â†’ Editor (new template)
  - `/email/templates/:id` â†’ Editor (existing template)
  - `/email/campaigns` â†’ Campaigns list page
  - `/email/campaigns/new` â†’ CampaignEditor (new)
  - `/email/campaigns/:id` â†’ CampaignDetail page
  - `/email/campaigns/:id/edit` â†’ CampaignEditor (existing)
- All routes were implemented in previous stories (US-040 through US-051)
- Typecheck passes

**Files changed:**

- backlog/backlog.json (updated US-052 passes status)

**Learnings for future iterations:**

- Route configuration should be verified against acceptance criteria even when pages are created incrementally
- In this codebase, routes are in App.tsx (not a separate router.tsx file)
