# Ralph Progress Log

## Codebase Patterns

- **Migration files**: Located at `apps/studio/drizzle/migrations/` with naming convention `XXXX_description.sql`
- **SQLite column naming**: Uses snake_case for columns (e.g., `first_name`, `created_at`)
- **Timestamps**: Use `text` type with `DEFAULT (datetime('now'))` for SQLite compatibility
- **Foreign keys**: Defined inline with column using `FOREIGN KEY ... REFERENCES` syntax
- **Indexes**: Created with `--> statement-breakpoint` separator between SQL statements
- **JSON fields**: Stored as `text` type (SQLite doesn't have native JSON type)
- **Pre-existing issues**: Typecheck error exists in Login.tsx:52 on main branch

---

## Iterations

### Iteration: 2026-01-20

**Story:** US-001 - Create email marketing database schema migration
**Status:** Complete

**What was done:**

- Created migration file at `drizzle/migrations/0005_add_email_marketing.sql`
- Implemented 8 tables: `subscribers`, `segments`, `segment_subscribers`, `email_templates`, `email_components`, `campaigns`, `email_sends`, `email_events`
- Added proper foreign key relationships between tables
- Created indexes on frequently queried columns (email, shopify_customer_id, status, campaign_id)
- Verified build passes (typecheck has pre-existing error unrelated to this change)

**Files changed:**

- `apps/studio/drizzle/migrations/0005_add_email_marketing.sql` (created)
- `backlog/backlog.json` (updated passes status)

**Learnings for future iterations:**

- SQLite uses `text` type for JSON data, datetime, and enums
- Migration file uses `--> statement-breakpoint` to separate SQL statements
- Build verification is sufficient when typecheck has pre-existing errors on main
- Status enum values are stored as text strings in SQLite (not native enums)

### Iteration: 2026-01-20 (continued)

**Story:** US-002 - Add Drizzle schema definitions for email marketing tables
**Status:** Complete

**What was done:**

- Added 8 Drizzle table definitions to `apps/studio/server/db/schema.ts`
- Tables defined: `subscribers`, `segments`, `segmentSubscribers`, `emailTemplates`, `emailComponents`, `campaigns`, `emailSends`, `emailEvents`
- Added Drizzle relations for all table relationships using `relations()` helper
- Exported Select and Insert types for each table (e.g., `Subscriber`, `NewSubscriber`)
- Used `text()` with `enum` option for status fields to match SQLite storage
- Verified build passes successfully

**Files changed:**

- `apps/studio/server/db/schema.ts` (modified - added 251 lines)
- `backlog/backlog.json` (updated US-002 passes status)

**Learnings for future iterations:**

- Drizzle uses `primaryKey({columns: [...]})` for composite primary keys in SQLite
- Relations are defined separately from tables using `relations()` from drizzle-orm
- Type inference uses `$inferSelect` and `$inferInsert` on table definitions
- Enum options in text() provide TypeScript typing but store as plain text in SQLite

### Iteration: 2026-01-20 (continued)

**Story:** US-003 - Create subscriber CRUD API routes
**Status:** Complete

**What was done:**

- Created `apps/studio/server/routes/email.ts` with subscriber CRUD endpoints
- Implemented `GET /api/email/subscribers` with pagination and filters (status, search, segmentId)
- Implemented `GET /api/email/subscribers/:id` returning subscriber with segment memberships
- Implemented `POST /api/email/subscribers` with email validation and duplicate checking
- Implemented `PATCH /api/email/subscribers/:id` for updating subscriber fields
- Implemented `DELETE /api/email/subscribers/:id` as soft-delete (sets status to 'unsubscribed')
- Registered email routes in `apps/studio/server/index.ts`
- All routes require authentication via authMiddleware

**Files changed:**

- `apps/studio/server/routes/email.ts` (created)
- `apps/studio/server/index.ts` (modified - added email routes)
- `backlog/backlog.json` (updated US-003 passes status)

**Learnings for future iterations:**

- Hono routes follow pattern: create Hono instance, apply middleware, define routes, export
- Status enum fields need explicit type assertion when comparing with query params (string â†’ enum type)
- Drizzle `inArray` operator useful for filtering by segment membership
- Use zValidator from @hono/zod-validator for request body validation
- Soft deletes preferred for subscriber management to preserve data integrity

### Iteration: 2026-01-20 (continued)

**Story:** US-004 - Implement Shopify customer sync service
**Status:** Complete

**What was done:**

- Created `apps/studio/server/services/shopifySync.ts` with Shopify customer sync functionality
- Implemented `syncCustomersFromShopify` function using Shopify Admin GraphQL API
- Used cursor-based pagination to handle stores with >250 customers (Shopify's maximum per request)
- Creates new subscribers for Shopify customers without existing records
- Updates existing subscribers if email/name/shopifyCustomerId changed
- Respects unsubscribed/bounced status - does not re-subscribe users
- Sets `source` field to 'shopify_sync' for new subscribers
- Checks Shopify's `emailMarketingConsent.marketingState` for initial subscription status
- Added SHOPIFY_ADMIN_API_TOKEN and SHOPIFY_STORE_DOMAIN to Env interface
- Returns sync stats object with created, updated, skipped, and total counts

**Files changed:**

- `apps/studio/server/services/shopifySync.ts` (created)
- `apps/studio/server/index.ts` (modified - added Shopify env vars to Env interface)
- `backlog/backlog.json` (updated US-004 passes status)

**Learnings for future iterations:**

- Shopify Admin GraphQL API uses cursor-based pagination via `after` parameter
- Shopify global IDs format: `gid://shopify/Customer/123` - extract numeric ID from last segment
- Shopify API version format: `2024-01` in URL path
- `X-Shopify-Access-Token` header required for authentication
- `emailMarketingConsent.marketingState` can be 'SUBSCRIBED', 'UNSUBSCRIBED', 'NOT_SUBSCRIBED', etc.
- Type `D1Database` imported from `@cloudflare/workers-types` for Cloudflare D1 database parameter

### Iteration: 2026-01-20 (continued)

**Story:** US-005 - Add Shopify customer webhooks endpoint
**Status:** Complete

**What was done:**

- Added `POST /api/email/webhooks/shopify` endpoint to `apps/studio/server/routes/email.ts`
- Implemented HMAC signature validation using Web Crypto API (`crypto.subtle`)
- Handled `customers/create` topic - creates new subscriber or updates existing with Shopify ID
- Handled `customers/update` topic - updates subscriber email/name if changed
- Handled `customers/delete` topic - marks subscriber as unsubscribed (soft delete)
- Added SHOPIFY_WEBHOOK_SECRET to Env interface
- Webhook endpoint does NOT require auth middleware - uses HMAC validation instead
- Returns 200 OK quickly to prevent Shopify retries on errors
- Logs all webhook events for debugging

**Files changed:**

- `apps/studio/server/routes/email.ts` (modified - added ~250 lines for webhook handler)
- `apps/studio/server/index.ts` (modified - added SHOPIFY_WEBHOOK_SECRET to Env interface)
- `backlog/backlog.json` (updated US-005 passes status)

**Learnings for future iterations:**

- Shopify webhook headers: `X-Shopify-Topic` for event type, `X-Shopify-Hmac-Sha256` for signature
- HMAC validation uses Web Crypto API: `crypto.subtle.importKey` + `crypto.subtle.sign`
- Shopify webhook payload uses snake_case (e.g., `first_name`, `email_marketing_consent`)
- Shopify webhook `email_marketing_consent.state` values: `subscribed`, `not_subscribed`, `unsubscribed`
- Webhook routes need to be defined BEFORE applying auth middleware via `emailRoutes.use('/path/*', authMiddleware)`
- Always return 200 OK to Shopify webhooks to prevent retries, even on internal errors

### Iteration: 2026-01-20 (continued)

**Story:** US-006 - Create subscribers list page UI
**Status:** Complete

**What was done:**

- Created `apps/studio/client/pages/email/Subscribers.tsx` with full subscriber list UI
- Implemented table with columns: Email, Name, Status, Source, Subscribed Date
- Added search input that filters by email or name (resets page to 1 on change)
- Added status filter dropdown with All Statuses, Active, Unsubscribed, Bounced options
- Implemented pagination with Previous/Next buttons (50 subscribers per page)
- Shows total subscriber count and active count in header
- Created StatusBadge component with color-coded badges (green/gray/red)
- Added loading spinner while fetching data
- Added empty state message when no subscribers match filters
- Added email API methods to `apps/studio/client/lib/api.ts` for all subscriber CRUD operations
- Registered `/email/subscribers` route in `apps/studio/client/App.tsx`
- Verified UI in browser using chrome-devtools MCP

**Files changed:**

- `apps/studio/client/pages/email/Subscribers.tsx` (created)
- `apps/studio/client/lib/api.ts` (modified - added email.subscribers API methods)
- `apps/studio/client/App.tsx` (modified - added route and import)
- `backlog/backlog.json` (updated US-006 passes status)

**Learnings for future iterations:**

- UI pages follow pattern from seo/Tracking.tsx: useState for filters, useQuery for data fetching
- Table styling: rounded-lg border bg-card wrapper, bg-muted/50 header row, divide-y divide-border body
- Status badges use bg-color/20 with text-color for consistent styling
- API client pattern: nested objects with methods that return `fetch().then(handleResponse<Type>)`
- Pagination resets to page 1 when filters change to avoid showing empty results
- Dev login available at localhost for testing without auth flow

### Iteration: 2026-01-20 (continued)

**Story:** US-007 - Add navigation for email marketing section
**Status:** Complete

**What was done:**

- Updated `apps/studio/client/components/layout/Sidebar.tsx` to add Email section
- Created inline MailIcon component (SVG envelope icon)
- Added Email section to navigation array with sub-items: Subscribers, Templates, Campaigns
- Updated section header rendering to display icon when present (using flex layout)
- Active state highlighting already handled by existing NavLink `isActive` prop
- Verified in browser: Email section with icon visible, navigation works, active state highlights correctly

**Files changed:**

- `apps/studio/client/components/layout/Sidebar.tsx` (modified - added 29 lines)
- `backlog/backlog.json` (updated US-007 passes status)

**Learnings for future iterations:**

- Sidebar sections can optionally have an `icon` property (React component)
- Icons rendered conditionally: `{section.icon && <section.icon className="h-4 w-4" />}`
- NavLink from react-router-dom provides `isActive` callback for active state styling
- Inline SVG icons work well when no icon library is installed

### Iteration: 2026-01-20 (continued)

**Story:** US-008 - Create segment CRUD API routes
**Status:** Complete

**What was done:**

- Added 5 segment CRUD endpoints to `apps/studio/server/routes/email.ts`
- `GET /api/email/segments` returns all segments ordered by createdAt (desc)
- `GET /api/email/segments/:id` returns segment with paginated subscriber list (includes subscriber details via join)
- `POST /api/email/segments` creates custom segment with name and optional filters JSON
- `PATCH /api/email/segments/:id` updates segment name and/or filters
- `DELETE /api/email/segments/:id` deletes segment (only custom type allowed - Shopify synced segments return 403)
- All segment routes require authentication via existing `emailRoutes.use('/segments/*', authMiddleware)`

**Files changed:**

- `apps/studio/server/routes/email.ts` (modified - added 182 lines for segment CRUD)
- `backlog/backlog.json` (updated US-008 passes status)

**Learnings for future iterations:**

- Segment DELETE endpoint should not allow deleting Shopify-synced segments to prevent data inconsistency
- JOIN with subscribers table in GET /segments/:id allows returning subscriber details in segment member list
- Pagination pattern reused from subscribers endpoint: count query + data query with limit/offset
- Filters stored as JSON string using `JSON.stringify(data.filters)`

### Iteration: 2026-01-20 (continued)

**Story:** US-009 - Implement Shopify segments sync
**Status:** Complete

**What was done:**

- Added `syncSegmentsFromShopify` function to `apps/studio/server/services/shopifySync.ts`
- Implemented `SEGMENTS_QUERY` GraphQL query to fetch all segments from Shopify
- Implemented `SEGMENT_MEMBERS_QUERY` GraphQL query with `customerSegmentMembers` to fetch segment members
- Added `fetchShopifySegments` and `fetchShopifySegmentMembers` helper functions with pagination support
- Function creates/updates segments with `type: 'shopify_sync'` and stores `shopifySegmentId`
- `syncSegmentMembers` helper syncs members by comparing Shopify member IDs with local segment memberships
- Adds new members to `segmentSubscribers` table, removes members no longer in Shopify segment
- Updates `subscriberCount` on segment after member sync
- Handles pagination for segments with >1000 members (uses cursor-based pagination)
- Added `SegmentSyncStats` interface for return type

**Files changed:**

- `apps/studio/server/services/shopifySync.ts` (modified - added ~270 lines)
- `backlog/backlog.json` (updated US-009 passes status)

**Learnings for future iterations:**

- Shopify `segments` query returns segments with `id`, `name`, `creationDate`, `lastEditDate`
- Shopify `customerSegmentMembers` query requires segment GID (not numeric ID) as `segmentId` parameter
- Segment member sync requires joining `segmentSubscribers` with `subscribers` to get `shopifyCustomerId` for comparison
- Use Set for efficient membership comparison when syncing (O(1) lookup vs O(n) array includes)
- `drizzle-orm` delete with compound where clause uses `and()` helper: `and(eq(a, x), eq(b, y))`

### Iteration: 2026-01-20 (continued)

**Story:** US-010 - Add manual segment sync trigger endpoint
**Status:** Complete

**What was done:**

- Added `POST /api/email/segments/sync` endpoint to `apps/studio/server/routes/email.ts`
- Implemented rate limiting (5 minutes between syncs) using in-memory tracking
- Uses `c.executionCtx.waitUntil()` for async execution - returns immediately with acknowledgment
- Syncs both customers and segments from Shopify in sequence
- Resets rate limit on failure so user can retry sooner
- Validates required environment variables (SHOPIFY_ADMIN_API_TOKEN, SHOPIFY_STORE_DOMAIN)
- Returns 429 Too Many Requests if rate limited, with retryAfterSeconds

**Files changed:**

- `apps/studio/server/routes/email.ts` (modified - added ~78 lines)
- `backlog/backlog.json` (updated US-010 passes status)

**Learnings for future iterations:**

- Cloudflare Workers use `c.executionCtx.waitUntil()` for async background tasks
- In-memory rate limiting works per-isolate; for production may need KV/durable objects
- Rate limit should be reset on failure to allow retry
- Return 429 status with `retryAfterSeconds` for rate-limited requests

### Iteration: 2026-01-20 (continued)

**Story:** US-011 - Create Header email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/Header.tsx` using @react-email/components
- Implemented Header component with Img and Section from @react-email/components
- Props: `logoUrl` (string, required) and `backgroundColor` (string, default #1a1a1a)
- Logo centered with 40px height, 24px top/bottom padding
- Exported `HeaderSchema` JSON for template editor integration
- Exported `HeaderDefaultProps` with sensible defaults
- Installed @react-email/components and @react-email/render dependencies

**Files changed:**

- `apps/studio/server/email-components/Header.tsx` (created)
- `apps/studio/package.json` (modified - added @react-email dependencies)
- `pnpm-lock.yaml` (updated)
- `backlog/backlog.json` (updated US-011 passes status)

**Learnings for future iterations:**

- @react-email/components provides email-safe React components (Img, Section, Row, Column, etc.)
- Email components should export both the component and a schema JSON for the editor
- Schema JSON should define prop types, labels, descriptions, defaults, and required fields
- Use `as const` for schema to get better TypeScript inference
- DefaultProps export useful for initializing component instances in the editor

### Iteration: 2026-01-20 (continued)

**Story:** US-012 - Create Hero email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/Hero.tsx` with all required props
- Props implemented: headline, subheadline, imageUrl, buttonText, buttonUrl, backgroundColor
- Headline styled with Founders Grotesk font fallback at 32px, weight 600
- Subheadline styled with ITC Avant Garde Gothic font fallback at 18px
- Button styled with Wakey yellow (#FAD103) background, 16px 32px padding, 8px border-radius
- Image has max-width: 100% for responsive scaling
- Text props support `{{firstName}}` style variable interpolation (rendered at template level)
- Exported HeroSchema JSON with all prop definitions for editor
- Exported HeroDefaultProps with sensible defaults

**Files changed:**

- `apps/studio/server/email-components/Hero.tsx` (created)
- `backlog/backlog.json` (updated US-012 passes status)

**Learnings for future iterations:**

- @react-email/components Button component uses `href` prop (not `url`)
- Variable interpolation `{{firstName}}` is passed through as-is; interpolation happens at render time
- Use optional chaining in render for optional props (e.g., `{imageUrl && <Img ... />}`)
- Text component from @react-email/components wraps content in inline styles for email compatibility

### Iteration: 2026-01-20 (continued)

**Story:** US-013 - Create TextBlock email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/TextBlock.tsx` for body text content
- Implemented TextBlock component with content, alignment, and fontSize props
- alignment options: 'left', 'center', 'right' (default: left)
- fontSize options: 'paragraph' (16px), 'small' (14px) (default: paragraph)
- Uses ITC Avant Garde Gothic font fallback with line-height 1.6 for readability
- Supports basic HTML (bold, italic, links) via dangerouslySetInnerHTML
- Exported TextBlockSchema JSON with textarea for content, select for alignment/fontSize
- Exported TextBlockDefaultProps with sensible defaults

**Files changed:**

- `apps/studio/server/email-components/TextBlock.tsx` (created)
- `backlog/backlog.json` (updated US-013 passes status)

**Learnings for future iterations:**

- Use `dangerouslySetInnerHTML` for components that accept HTML content (bold, italic, links)
- Select schema fields need `options` array with `{value, label}` objects
- Keep font size options simple (paragraph/small) rather than arbitrary pixel values
- Text component styling uses inline `style` prop for email client compatibility

### Iteration: 2026-01-20 (continued)

**Story:** US-014 - Create CallToAction email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/CallToAction.tsx` for CTA buttons
- Implemented CallToAction component with text, url, and variant props
- Primary variant: #FAD103 background, #1a1a1a text (Wakey yellow)
- Secondary variant: transparent background, #FAD103 border and text
- Button uses Founders Grotesk font, 16px 32px padding, 8px border-radius
- Button centered in Section with 24px padding
- Exported CallToActionSchema JSON with select options for variant
- Exported CallToActionDefaultProps with sensible defaults
- Build passes (pre-existing typecheck error in Login.tsx unrelated)

**Files changed:**

- `apps/studio/server/email-components/CallToAction.tsx` (created)
- `backlog/backlog.json` (updated US-014 passes status)

**Learnings for future iterations:**

- @react-email/components Button uses `href` prop for the URL destination
- Variant styling uses conditional expressions based on props (e.g., `isPrimary ? 'value1' : 'value2'`)
- Email buttons need explicit `display: 'inline-block'` for proper rendering
- Secondary button variant uses transparent background with border for outline effect

### Iteration: 2026-01-20 (continued)

**Story:** US-015 - Create ProductGrid email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/ProductGrid.tsx` for showcasing products
- Implemented ProductGrid component with products array and columns (2 or 3) props
- Product interface: `{imageUrl, title, price, url}`
- Uses Row and Column from @react-email/components for grid layout
- Products limited to max 6 using `.slice(0, 6)`
- Each product wrapped in Link, shows image (with border-radius), title, and price
- Title uses Founders Grotesk font, price uses muted color (#666666)
- Empty columns added to maintain grid alignment when row is not full
- Exported ProductGridSchema with array type and itemSchema for editor
- Exported ProductGridDefaultProps with 2 sample products
- Build passes (pre-existing typecheck error in Login.tsx unrelated)

**Files changed:**

- `apps/studio/server/email-components/ProductGrid.tsx` (created)
- `backlog/backlog.json` (updated US-015 passes status)

**Learnings for future iterations:**

- Array props in schema use `type: 'array'` with `itemSchema` object defining item fields
- Row/Column components from @react-email work for email-compatible grid layouts
- Use percentage widths for columns (50% for 2-col, 33.33% for 3-col)
- Add empty Column components to fill rows that aren't complete to maintain alignment
- Link component wraps entire product card for click-through to product URL

