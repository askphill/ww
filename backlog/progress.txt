# Ralph Progress Log

## Codebase Patterns

- **Migration files**: Located at `apps/studio/drizzle/migrations/` with naming convention `XXXX_description.sql`
- **SQLite column naming**: Uses snake_case for columns (e.g., `first_name`, `created_at`)
- **Timestamps**: Use `text` type with `DEFAULT (datetime('now'))` for SQLite compatibility
- **Foreign keys**: Defined inline with column using `FOREIGN KEY ... REFERENCES` syntax
- **Indexes**: Created with `--> statement-breakpoint` separator between SQL statements
- **JSON fields**: Stored as `text` type (SQLite doesn't have native JSON type)
- **Pre-existing issues**: Typecheck error exists in Login.tsx:52 on main branch

---

## Iterations

### Iteration: 2026-01-20

**Story:** US-001 - Create email marketing database schema migration
**Status:** Complete

**What was done:**

- Created migration file at `drizzle/migrations/0005_add_email_marketing.sql`
- Implemented 8 tables: `subscribers`, `segments`, `segment_subscribers`, `email_templates`, `email_components`, `campaigns`, `email_sends`, `email_events`
- Added proper foreign key relationships between tables
- Created indexes on frequently queried columns (email, shopify_customer_id, status, campaign_id)
- Verified build passes (typecheck has pre-existing error unrelated to this change)

**Files changed:**

- `apps/studio/drizzle/migrations/0005_add_email_marketing.sql` (created)
- `backlog/backlog.json` (updated passes status)

**Learnings for future iterations:**

- SQLite uses `text` type for JSON data, datetime, and enums
- Migration file uses `--> statement-breakpoint` to separate SQL statements
- Build verification is sufficient when typecheck has pre-existing errors on main
- Status enum values are stored as text strings in SQLite (not native enums)

### Iteration: 2026-01-20 (continued)

**Story:** US-002 - Add Drizzle schema definitions for email marketing tables
**Status:** Complete

**What was done:**

- Added 8 Drizzle table definitions to `apps/studio/server/db/schema.ts`
- Tables defined: `subscribers`, `segments`, `segmentSubscribers`, `emailTemplates`, `emailComponents`, `campaigns`, `emailSends`, `emailEvents`
- Added Drizzle relations for all table relationships using `relations()` helper
- Exported Select and Insert types for each table (e.g., `Subscriber`, `NewSubscriber`)
- Used `text()` with `enum` option for status fields to match SQLite storage
- Verified build passes successfully

**Files changed:**

- `apps/studio/server/db/schema.ts` (modified - added 251 lines)
- `backlog/backlog.json` (updated US-002 passes status)

**Learnings for future iterations:**

- Drizzle uses `primaryKey({columns: [...]})` for composite primary keys in SQLite
- Relations are defined separately from tables using `relations()` from drizzle-orm
- Type inference uses `$inferSelect` and `$inferInsert` on table definitions
- Enum options in text() provide TypeScript typing but store as plain text in SQLite

### Iteration: 2026-01-20 (continued)

**Story:** US-003 - Create subscriber CRUD API routes
**Status:** Complete

**What was done:**

- Created `apps/studio/server/routes/email.ts` with subscriber CRUD endpoints
- Implemented `GET /api/email/subscribers` with pagination and filters (status, search, segmentId)
- Implemented `GET /api/email/subscribers/:id` returning subscriber with segment memberships
- Implemented `POST /api/email/subscribers` with email validation and duplicate checking
- Implemented `PATCH /api/email/subscribers/:id` for updating subscriber fields
- Implemented `DELETE /api/email/subscribers/:id` as soft-delete (sets status to 'unsubscribed')
- Registered email routes in `apps/studio/server/index.ts`
- All routes require authentication via authMiddleware

**Files changed:**

- `apps/studio/server/routes/email.ts` (created)
- `apps/studio/server/index.ts` (modified - added email routes)
- `backlog/backlog.json` (updated US-003 passes status)

**Learnings for future iterations:**

- Hono routes follow pattern: create Hono instance, apply middleware, define routes, export
- Status enum fields need explicit type assertion when comparing with query params (string â†’ enum type)
- Drizzle `inArray` operator useful for filtering by segment membership
- Use zValidator from @hono/zod-validator for request body validation
- Soft deletes preferred for subscriber management to preserve data integrity

### Iteration: 2026-01-20 (continued)

**Story:** US-004 - Implement Shopify customer sync service
**Status:** Complete

**What was done:**

- Created `apps/studio/server/services/shopifySync.ts` with Shopify customer sync functionality
- Implemented `syncCustomersFromShopify` function using Shopify Admin GraphQL API
- Used cursor-based pagination to handle stores with >250 customers (Shopify's maximum per request)
- Creates new subscribers for Shopify customers without existing records
- Updates existing subscribers if email/name/shopifyCustomerId changed
- Respects unsubscribed/bounced status - does not re-subscribe users
- Sets `source` field to 'shopify_sync' for new subscribers
- Checks Shopify's `emailMarketingConsent.marketingState` for initial subscription status
- Added SHOPIFY_ADMIN_API_TOKEN and SHOPIFY_STORE_DOMAIN to Env interface
- Returns sync stats object with created, updated, skipped, and total counts

**Files changed:**

- `apps/studio/server/services/shopifySync.ts` (created)
- `apps/studio/server/index.ts` (modified - added Shopify env vars to Env interface)
- `backlog/backlog.json` (updated US-004 passes status)

**Learnings for future iterations:**

- Shopify Admin GraphQL API uses cursor-based pagination via `after` parameter
- Shopify global IDs format: `gid://shopify/Customer/123` - extract numeric ID from last segment
- Shopify API version format: `2024-01` in URL path
- `X-Shopify-Access-Token` header required for authentication
- `emailMarketingConsent.marketingState` can be 'SUBSCRIBED', 'UNSUBSCRIBED', 'NOT_SUBSCRIBED', etc.
- Type `D1Database` imported from `@cloudflare/workers-types` for Cloudflare D1 database parameter

### Iteration: 2026-01-20 (continued)

**Story:** US-005 - Add Shopify customer webhooks endpoint
**Status:** Complete

**What was done:**

- Added `POST /api/email/webhooks/shopify` endpoint to `apps/studio/server/routes/email.ts`
- Implemented HMAC signature validation using Web Crypto API (`crypto.subtle`)
- Handled `customers/create` topic - creates new subscriber or updates existing with Shopify ID
- Handled `customers/update` topic - updates subscriber email/name if changed
- Handled `customers/delete` topic - marks subscriber as unsubscribed (soft delete)
- Added SHOPIFY_WEBHOOK_SECRET to Env interface
- Webhook endpoint does NOT require auth middleware - uses HMAC validation instead
- Returns 200 OK quickly to prevent Shopify retries on errors
- Logs all webhook events for debugging

**Files changed:**

- `apps/studio/server/routes/email.ts` (modified - added ~250 lines for webhook handler)
- `apps/studio/server/index.ts` (modified - added SHOPIFY_WEBHOOK_SECRET to Env interface)
- `backlog/backlog.json` (updated US-005 passes status)

**Learnings for future iterations:**

- Shopify webhook headers: `X-Shopify-Topic` for event type, `X-Shopify-Hmac-Sha256` for signature
- HMAC validation uses Web Crypto API: `crypto.subtle.importKey` + `crypto.subtle.sign`
- Shopify webhook payload uses snake_case (e.g., `first_name`, `email_marketing_consent`)
- Shopify webhook `email_marketing_consent.state` values: `subscribed`, `not_subscribed`, `unsubscribed`
- Webhook routes need to be defined BEFORE applying auth middleware via `emailRoutes.use('/path/*', authMiddleware)`
- Always return 200 OK to Shopify webhooks to prevent retries, even on internal errors

### Iteration: 2026-01-20 (continued)

**Story:** US-006 - Create subscribers list page UI
**Status:** Complete

**What was done:**

- Created `apps/studio/client/pages/email/Subscribers.tsx` with full subscriber list UI
- Implemented table with columns: Email, Name, Status, Source, Subscribed Date
- Added search input that filters by email or name (resets page to 1 on change)
- Added status filter dropdown with All Statuses, Active, Unsubscribed, Bounced options
- Implemented pagination with Previous/Next buttons (50 subscribers per page)
- Shows total subscriber count and active count in header
- Created StatusBadge component with color-coded badges (green/gray/red)
- Added loading spinner while fetching data
- Added empty state message when no subscribers match filters
- Added email API methods to `apps/studio/client/lib/api.ts` for all subscriber CRUD operations
- Registered `/email/subscribers` route in `apps/studio/client/App.tsx`
- Verified UI in browser using chrome-devtools MCP

**Files changed:**

- `apps/studio/client/pages/email/Subscribers.tsx` (created)
- `apps/studio/client/lib/api.ts` (modified - added email.subscribers API methods)
- `apps/studio/client/App.tsx` (modified - added route and import)
- `backlog/backlog.json` (updated US-006 passes status)

**Learnings for future iterations:**

- UI pages follow pattern from seo/Tracking.tsx: useState for filters, useQuery for data fetching
- Table styling: rounded-lg border bg-card wrapper, bg-muted/50 header row, divide-y divide-border body
- Status badges use bg-color/20 with text-color for consistent styling
- API client pattern: nested objects with methods that return `fetch().then(handleResponse<Type>)`
- Pagination resets to page 1 when filters change to avoid showing empty results
- Dev login available at localhost for testing without auth flow

