# Ralph Progress Log

## Codebase Patterns

- **Migration files**: Located at `apps/studio/drizzle/migrations/` with naming convention `XXXX_description.sql`
- **SQLite column naming**: Uses snake_case for columns (e.g., `first_name`, `created_at`)
- **Timestamps**: Use `text` type with `DEFAULT (datetime('now'))` for SQLite compatibility
- **Foreign keys**: Defined inline with column using `FOREIGN KEY ... REFERENCES` syntax
- **Indexes**: Created with `--> statement-breakpoint` separator between SQL statements
- **JSON fields**: Stored as `text` type (SQLite doesn't have native JSON type)
- **Pre-existing issues**: Typecheck error exists in Login.tsx:52 on main branch

---

## Iterations

### Iteration: 2026-01-20

**Story:** US-001 - Create email marketing database schema migration
**Status:** Complete

**What was done:**

- Created migration file at `drizzle/migrations/0005_add_email_marketing.sql`
- Implemented 8 tables: `subscribers`, `segments`, `segment_subscribers`, `email_templates`, `email_components`, `campaigns`, `email_sends`, `email_events`
- Added proper foreign key relationships between tables
- Created indexes on frequently queried columns (email, shopify_customer_id, status, campaign_id)
- Verified build passes (typecheck has pre-existing error unrelated to this change)

**Files changed:**

- `apps/studio/drizzle/migrations/0005_add_email_marketing.sql` (created)
- `backlog/backlog.json` (updated passes status)

**Learnings for future iterations:**

- SQLite uses `text` type for JSON data, datetime, and enums
- Migration file uses `--> statement-breakpoint` to separate SQL statements
- Build verification is sufficient when typecheck has pre-existing errors on main
- Status enum values are stored as text strings in SQLite (not native enums)

### Iteration: 2026-01-20 (continued)

**Story:** US-002 - Add Drizzle schema definitions for email marketing tables
**Status:** Complete

**What was done:**

- Added 8 Drizzle table definitions to `apps/studio/server/db/schema.ts`
- Tables defined: `subscribers`, `segments`, `segmentSubscribers`, `emailTemplates`, `emailComponents`, `campaigns`, `emailSends`, `emailEvents`
- Added Drizzle relations for all table relationships using `relations()` helper
- Exported Select and Insert types for each table (e.g., `Subscriber`, `NewSubscriber`)
- Used `text()` with `enum` option for status fields to match SQLite storage
- Verified build passes successfully

**Files changed:**

- `apps/studio/server/db/schema.ts` (modified - added 251 lines)
- `backlog/backlog.json` (updated US-002 passes status)

**Learnings for future iterations:**

- Drizzle uses `primaryKey({columns: [...]})` for composite primary keys in SQLite
- Relations are defined separately from tables using `relations()` from drizzle-orm
- Type inference uses `$inferSelect` and `$inferInsert` on table definitions
- Enum options in text() provide TypeScript typing but store as plain text in SQLite

### Iteration: 2026-01-20 (continued)

**Story:** US-003 - Create subscriber CRUD API routes
**Status:** Complete

**What was done:**

- Created `apps/studio/server/routes/email.ts` with subscriber CRUD endpoints
- Implemented `GET /api/email/subscribers` with pagination and filters (status, search, segmentId)
- Implemented `GET /api/email/subscribers/:id` returning subscriber with segment memberships
- Implemented `POST /api/email/subscribers` with email validation and duplicate checking
- Implemented `PATCH /api/email/subscribers/:id` for updating subscriber fields
- Implemented `DELETE /api/email/subscribers/:id` as soft-delete (sets status to 'unsubscribed')
- Registered email routes in `apps/studio/server/index.ts`
- All routes require authentication via authMiddleware

**Files changed:**

- `apps/studio/server/routes/email.ts` (created)
- `apps/studio/server/index.ts` (modified - added email routes)
- `backlog/backlog.json` (updated US-003 passes status)

**Learnings for future iterations:**

- Hono routes follow pattern: create Hono instance, apply middleware, define routes, export
- Status enum fields need explicit type assertion when comparing with query params (string â†’ enum type)
- Drizzle `inArray` operator useful for filtering by segment membership
- Use zValidator from @hono/zod-validator for request body validation
- Soft deletes preferred for subscriber management to preserve data integrity

### Iteration: 2026-01-20 (continued)

**Story:** US-004 - Implement Shopify customer sync service
**Status:** Complete

**What was done:**

- Created `apps/studio/server/services/shopifySync.ts` with Shopify customer sync functionality
- Implemented `syncCustomersFromShopify` function using Shopify Admin GraphQL API
- Used cursor-based pagination to handle stores with >250 customers (Shopify's maximum per request)
- Creates new subscribers for Shopify customers without existing records
- Updates existing subscribers if email/name/shopifyCustomerId changed
- Respects unsubscribed/bounced status - does not re-subscribe users
- Sets `source` field to 'shopify_sync' for new subscribers
- Checks Shopify's `emailMarketingConsent.marketingState` for initial subscription status
- Added SHOPIFY_ADMIN_API_TOKEN and SHOPIFY_STORE_DOMAIN to Env interface
- Returns sync stats object with created, updated, skipped, and total counts

**Files changed:**

- `apps/studio/server/services/shopifySync.ts` (created)
- `apps/studio/server/index.ts` (modified - added Shopify env vars to Env interface)
- `backlog/backlog.json` (updated US-004 passes status)

**Learnings for future iterations:**

- Shopify Admin GraphQL API uses cursor-based pagination via `after` parameter
- Shopify global IDs format: `gid://shopify/Customer/123` - extract numeric ID from last segment
- Shopify API version format: `2024-01` in URL path
- `X-Shopify-Access-Token` header required for authentication
- `emailMarketingConsent.marketingState` can be 'SUBSCRIBED', 'UNSUBSCRIBED', 'NOT_SUBSCRIBED', etc.
- Type `D1Database` imported from `@cloudflare/workers-types` for Cloudflare D1 database parameter

### Iteration: 2026-01-20 (continued)

**Story:** US-005 - Add Shopify customer webhooks endpoint
**Status:** Complete

**What was done:**

- Added `POST /api/email/webhooks/shopify` endpoint to `apps/studio/server/routes/email.ts`
- Implemented HMAC signature validation using Web Crypto API (`crypto.subtle`)
- Handled `customers/create` topic - creates new subscriber or updates existing with Shopify ID
- Handled `customers/update` topic - updates subscriber email/name if changed
- Handled `customers/delete` topic - marks subscriber as unsubscribed (soft delete)
- Added SHOPIFY_WEBHOOK_SECRET to Env interface
- Webhook endpoint does NOT require auth middleware - uses HMAC validation instead
- Returns 200 OK quickly to prevent Shopify retries on errors
- Logs all webhook events for debugging

**Files changed:**

- `apps/studio/server/routes/email.ts` (modified - added ~250 lines for webhook handler)
- `apps/studio/server/index.ts` (modified - added SHOPIFY_WEBHOOK_SECRET to Env interface)
- `backlog/backlog.json` (updated US-005 passes status)

**Learnings for future iterations:**

- Shopify webhook headers: `X-Shopify-Topic` for event type, `X-Shopify-Hmac-Sha256` for signature
- HMAC validation uses Web Crypto API: `crypto.subtle.importKey` + `crypto.subtle.sign`
- Shopify webhook payload uses snake_case (e.g., `first_name`, `email_marketing_consent`)
- Shopify webhook `email_marketing_consent.state` values: `subscribed`, `not_subscribed`, `unsubscribed`
- Webhook routes need to be defined BEFORE applying auth middleware via `emailRoutes.use('/path/*', authMiddleware)`
- Always return 200 OK to Shopify webhooks to prevent retries, even on internal errors

### Iteration: 2026-01-20 (continued)

**Story:** US-006 - Create subscribers list page UI
**Status:** Complete

**What was done:**

- Created `apps/studio/client/pages/email/Subscribers.tsx` with full subscriber list UI
- Implemented table with columns: Email, Name, Status, Source, Subscribed Date
- Added search input that filters by email or name (resets page to 1 on change)
- Added status filter dropdown with All Statuses, Active, Unsubscribed, Bounced options
- Implemented pagination with Previous/Next buttons (50 subscribers per page)
- Shows total subscriber count and active count in header
- Created StatusBadge component with color-coded badges (green/gray/red)
- Added loading spinner while fetching data
- Added empty state message when no subscribers match filters
- Added email API methods to `apps/studio/client/lib/api.ts` for all subscriber CRUD operations
- Registered `/email/subscribers` route in `apps/studio/client/App.tsx`
- Verified UI in browser using chrome-devtools MCP

**Files changed:**

- `apps/studio/client/pages/email/Subscribers.tsx` (created)
- `apps/studio/client/lib/api.ts` (modified - added email.subscribers API methods)
- `apps/studio/client/App.tsx` (modified - added route and import)
- `backlog/backlog.json` (updated US-006 passes status)

**Learnings for future iterations:**

- UI pages follow pattern from seo/Tracking.tsx: useState for filters, useQuery for data fetching
- Table styling: rounded-lg border bg-card wrapper, bg-muted/50 header row, divide-y divide-border body
- Status badges use bg-color/20 with text-color for consistent styling
- API client pattern: nested objects with methods that return `fetch().then(handleResponse<Type>)`
- Pagination resets to page 1 when filters change to avoid showing empty results
- Dev login available at localhost for testing without auth flow

### Iteration: 2026-01-20 (continued)

**Story:** US-007 - Add navigation for email marketing section
**Status:** Complete

**What was done:**

- Updated `apps/studio/client/components/layout/Sidebar.tsx` to add Email section
- Created inline MailIcon component (SVG envelope icon)
- Added Email section to navigation array with sub-items: Subscribers, Templates, Campaigns
- Updated section header rendering to display icon when present (using flex layout)
- Active state highlighting already handled by existing NavLink `isActive` prop
- Verified in browser: Email section with icon visible, navigation works, active state highlights correctly

**Files changed:**

- `apps/studio/client/components/layout/Sidebar.tsx` (modified - added 29 lines)
- `backlog/backlog.json` (updated US-007 passes status)

**Learnings for future iterations:**

- Sidebar sections can optionally have an `icon` property (React component)
- Icons rendered conditionally: `{section.icon && <section.icon className="h-4 w-4" />}`
- NavLink from react-router-dom provides `isActive` callback for active state styling
- Inline SVG icons work well when no icon library is installed

### Iteration: 2026-01-20 (continued)

**Story:** US-008 - Create segment CRUD API routes
**Status:** Complete

**What was done:**

- Added 5 segment CRUD endpoints to `apps/studio/server/routes/email.ts`
- `GET /api/email/segments` returns all segments ordered by createdAt (desc)
- `GET /api/email/segments/:id` returns segment with paginated subscriber list (includes subscriber details via join)
- `POST /api/email/segments` creates custom segment with name and optional filters JSON
- `PATCH /api/email/segments/:id` updates segment name and/or filters
- `DELETE /api/email/segments/:id` deletes segment (only custom type allowed - Shopify synced segments return 403)
- All segment routes require authentication via existing `emailRoutes.use('/segments/*', authMiddleware)`

**Files changed:**

- `apps/studio/server/routes/email.ts` (modified - added 182 lines for segment CRUD)
- `backlog/backlog.json` (updated US-008 passes status)

**Learnings for future iterations:**

- Segment DELETE endpoint should not allow deleting Shopify-synced segments to prevent data inconsistency
- JOIN with subscribers table in GET /segments/:id allows returning subscriber details in segment member list
- Pagination pattern reused from subscribers endpoint: count query + data query with limit/offset
- Filters stored as JSON string using `JSON.stringify(data.filters)`

### Iteration: 2026-01-20 (continued)

**Story:** US-009 - Implement Shopify segments sync
**Status:** Complete

**What was done:**

- Added `syncSegmentsFromShopify` function to `apps/studio/server/services/shopifySync.ts`
- Implemented `SEGMENTS_QUERY` GraphQL query to fetch all segments from Shopify
- Implemented `SEGMENT_MEMBERS_QUERY` GraphQL query with `customerSegmentMembers` to fetch segment members
- Added `fetchShopifySegments` and `fetchShopifySegmentMembers` helper functions with pagination support
- Function creates/updates segments with `type: 'shopify_sync'` and stores `shopifySegmentId`
- `syncSegmentMembers` helper syncs members by comparing Shopify member IDs with local segment memberships
- Adds new members to `segmentSubscribers` table, removes members no longer in Shopify segment
- Updates `subscriberCount` on segment after member sync
- Handles pagination for segments with >1000 members (uses cursor-based pagination)
- Added `SegmentSyncStats` interface for return type

**Files changed:**

- `apps/studio/server/services/shopifySync.ts` (modified - added ~270 lines)
- `backlog/backlog.json` (updated US-009 passes status)

**Learnings for future iterations:**

- Shopify `segments` query returns segments with `id`, `name`, `creationDate`, `lastEditDate`
- Shopify `customerSegmentMembers` query requires segment GID (not numeric ID) as `segmentId` parameter
- Segment member sync requires joining `segmentSubscribers` with `subscribers` to get `shopifyCustomerId` for comparison
- Use Set for efficient membership comparison when syncing (O(1) lookup vs O(n) array includes)
- `drizzle-orm` delete with compound where clause uses `and()` helper: `and(eq(a, x), eq(b, y))`

### Iteration: 2026-01-20 (continued)

**Story:** US-010 - Add manual segment sync trigger endpoint
**Status:** Complete

**What was done:**

- Added `POST /api/email/segments/sync` endpoint to `apps/studio/server/routes/email.ts`
- Implemented rate limiting (5 minutes between syncs) using in-memory tracking
- Uses `c.executionCtx.waitUntil()` for async execution - returns immediately with acknowledgment
- Syncs both customers and segments from Shopify in sequence
- Resets rate limit on failure so user can retry sooner
- Validates required environment variables (SHOPIFY_ADMIN_API_TOKEN, SHOPIFY_STORE_DOMAIN)
- Returns 429 Too Many Requests if rate limited, with retryAfterSeconds

**Files changed:**

- `apps/studio/server/routes/email.ts` (modified - added ~78 lines)
- `backlog/backlog.json` (updated US-010 passes status)

**Learnings for future iterations:**

- Cloudflare Workers use `c.executionCtx.waitUntil()` for async background tasks
- In-memory rate limiting works per-isolate; for production may need KV/durable objects
- Rate limit should be reset on failure to allow retry
- Return 429 status with `retryAfterSeconds` for rate-limited requests

### Iteration: 2026-01-20 (continued)

**Story:** US-011 - Create Header email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/Header.tsx` using @react-email/components
- Implemented Header component with Img and Section from @react-email/components
- Props: `logoUrl` (string, required) and `backgroundColor` (string, default #1a1a1a)
- Logo centered with 40px height, 24px top/bottom padding
- Exported `HeaderSchema` JSON for template editor integration
- Exported `HeaderDefaultProps` with sensible defaults
- Installed @react-email/components and @react-email/render dependencies

**Files changed:**

- `apps/studio/server/email-components/Header.tsx` (created)
- `apps/studio/package.json` (modified - added @react-email dependencies)
- `pnpm-lock.yaml` (updated)
- `backlog/backlog.json` (updated US-011 passes status)

**Learnings for future iterations:**

- @react-email/components provides email-safe React components (Img, Section, Row, Column, etc.)
- Email components should export both the component and a schema JSON for the editor
- Schema JSON should define prop types, labels, descriptions, defaults, and required fields
- Use `as const` for schema to get better TypeScript inference
- DefaultProps export useful for initializing component instances in the editor

### Iteration: 2026-01-20 (continued)

**Story:** US-012 - Create Hero email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/Hero.tsx` with all required props
- Props implemented: headline, subheadline, imageUrl, buttonText, buttonUrl, backgroundColor
- Headline styled with Founders Grotesk font fallback at 32px, weight 600
- Subheadline styled with ITC Avant Garde Gothic font fallback at 18px
- Button styled with Wakey yellow (#FAD103) background, 16px 32px padding, 8px border-radius
- Image has max-width: 100% for responsive scaling
- Text props support `{{firstName}}` style variable interpolation (rendered at template level)
- Exported HeroSchema JSON with all prop definitions for editor
- Exported HeroDefaultProps with sensible defaults

**Files changed:**

- `apps/studio/server/email-components/Hero.tsx` (created)
- `backlog/backlog.json` (updated US-012 passes status)

**Learnings for future iterations:**

- @react-email/components Button component uses `href` prop (not `url`)
- Variable interpolation `{{firstName}}` is passed through as-is; interpolation happens at render time
- Use optional chaining in render for optional props (e.g., `{imageUrl && <Img ... />}`)
- Text component from @react-email/components wraps content in inline styles for email compatibility

### Iteration: 2026-01-20 (continued)

**Story:** US-013 - Create TextBlock email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/TextBlock.tsx` for body text content
- Implemented TextBlock component with content, alignment, and fontSize props
- alignment options: 'left', 'center', 'right' (default: left)
- fontSize options: 'paragraph' (16px), 'small' (14px) (default: paragraph)
- Uses ITC Avant Garde Gothic font fallback with line-height 1.6 for readability
- Supports basic HTML (bold, italic, links) via dangerouslySetInnerHTML
- Exported TextBlockSchema JSON with textarea for content, select for alignment/fontSize
- Exported TextBlockDefaultProps with sensible defaults

**Files changed:**

- `apps/studio/server/email-components/TextBlock.tsx` (created)
- `backlog/backlog.json` (updated US-013 passes status)

**Learnings for future iterations:**

- Use `dangerouslySetInnerHTML` for components that accept HTML content (bold, italic, links)
- Select schema fields need `options` array with `{value, label}` objects
- Keep font size options simple (paragraph/small) rather than arbitrary pixel values
- Text component styling uses inline `style` prop for email client compatibility

### Iteration: 2026-01-20 (continued)

**Story:** US-014 - Create CallToAction email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/CallToAction.tsx` for CTA buttons
- Implemented CallToAction component with text, url, and variant props
- Primary variant: #FAD103 background, #1a1a1a text (Wakey yellow)
- Secondary variant: transparent background, #FAD103 border and text
- Button uses Founders Grotesk font, 16px 32px padding, 8px border-radius
- Button centered in Section with 24px padding
- Exported CallToActionSchema JSON with select options for variant
- Exported CallToActionDefaultProps with sensible defaults
- Build passes (pre-existing typecheck error in Login.tsx unrelated)

**Files changed:**

- `apps/studio/server/email-components/CallToAction.tsx` (created)
- `backlog/backlog.json` (updated US-014 passes status)

**Learnings for future iterations:**

- @react-email/components Button uses `href` prop for the URL destination
- Variant styling uses conditional expressions based on props (e.g., `isPrimary ? 'value1' : 'value2'`)
- Email buttons need explicit `display: 'inline-block'` for proper rendering
- Secondary button variant uses transparent background with border for outline effect

### Iteration: 2026-01-20 (continued)

**Story:** US-015 - Create ProductGrid email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/ProductGrid.tsx` for showcasing products
- Implemented ProductGrid component with products array and columns (2 or 3) props
- Product interface: `{imageUrl, title, price, url}`
- Uses Row and Column from @react-email/components for grid layout
- Products limited to max 6 using `.slice(0, 6)`
- Each product wrapped in Link, shows image (with border-radius), title, and price
- Title uses Founders Grotesk font, price uses muted color (#666666)
- Empty columns added to maintain grid alignment when row is not full
- Exported ProductGridSchema with array type and itemSchema for editor
- Exported ProductGridDefaultProps with 2 sample products
- Build passes (pre-existing typecheck error in Login.tsx unrelated)

**Files changed:**

- `apps/studio/server/email-components/ProductGrid.tsx` (created)
- `backlog/backlog.json` (updated US-015 passes status)

**Learnings for future iterations:**

- Array props in schema use `type: 'array'` with `itemSchema` object defining item fields
- Row/Column components from @react-email work for email-compatible grid layouts
- Use percentage widths for columns (50% for 2-col, 33.33% for 3-col)
- Add empty Column components to fill rows that aren't complete to maintain alignment
- Link component wraps entire product card for click-through to product URL

### Iteration: 2026-01-20 (continued)

**Story:** US-016 - Create Footer email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/Footer.tsx` for CAN-SPAM compliant email footers
- Implemented Footer component with unsubscribeUrl, address, and socialLinks props
- socialLinks accepts array of `{platform: 'instagram' | 'tiktok', url: string}` objects
- Physical address displayed in muted text (#666666) for CAN-SPAM compliance
- Unsubscribe link underlined for prominence and easy clickability
- Created inline SVG icons for Instagram and TikTok (no external dependencies)
- Social icons render conditionally based on socialLinks array
- Dark background (#1a1a1a) matches Wakey brand
- Exported FooterSchema JSON with array itemSchema for socialLinks
- Exported FooterDefaultProps with sample Instagram/TikTok links

**Files changed:**

- `apps/studio/server/email-components/Footer.tsx` (created)
- `backlog/backlog.json` (updated US-016 passes status)

**Learnings for future iterations:**

- Inline SVG components work well for email icons (no external library needed)
- CAN-SPAM requires physical address in all marketing emails
- Unsubscribe link should be underlined/prominent for legal compliance
- Social links array schema uses `itemSchema` with nested field definitions
- `{{unsubscribeUrl}}` placeholder will be interpolated at send time with signed token URL

### Iteration: 2026-01-20 (continued)

**Story:** US-017 - Create Divider email component
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/Divider.tsx` for visual separation
- Implemented Divider component with color and spacing props
- Uses Hr component from @react-email/components for horizontal rule
- color prop defaults to #e0e0e0 (light gray)
- spacing prop: 'small' (8px), 'medium' (16px), 'large' (32px)
- Wraps Hr in Section for padding control
- Exported DividerSchema JSON for template editor with color picker and select
- Exported DividerDefaultProps with sensible defaults

**Files changed:**

- `apps/studio/server/email-components/Divider.tsx` (created)
- `backlog/backlog.json` (updated US-017 passes status)

**Learnings for future iterations:**

- @react-email/components provides Hr component for horizontal rules
- Spacing can be controlled via Section wrapper with padding styles
- Use `as const` on SPACING_MAP for better TypeScript inference
- Color picker schema type uses `type: 'color'`

### Iteration: 2026-01-20 (continued)

**Story:** US-018 - Create component registry and renderer service
**Status:** Complete

**What was done:**

- Created `apps/studio/server/email-components/index.ts` as central component registry
- Registry exports all 7 components (Header, Hero, TextBlock, CallToAction, ProductGrid, Footer, Divider) with schemas and default props
- Created `apps/studio/server/services/emailRenderer.ts` for template rendering
- Implemented `renderTemplate(db, templateId, variables)` - fetches template from DB and renders to HTML/text
- Implemented `renderComponents(components, variables, previewText)` - renders components directly for previews
- Implemented `interpolateProps()` for recursive variable interpolation in string props
- Handles `{{variableName}}` syntax and replaces with variable values
- Missing variables replaced with empty string (graceful fallback)
- Uses @react-email/render to convert React components to HTML string
- Uses Html, Body, Container, Head, Preview components from @react-email for email structure
- Build passes (pre-existing typecheck error in Login.tsx not related)

**Files changed:**

- `apps/studio/server/email-components/index.ts` (created)
- `apps/studio/server/services/emailRenderer.ts` (created)
- `backlog/backlog.json` (updated US-018 passes status)

**Learnings for future iterations:**

- Component registry uses `AnyComponent = React.ComponentType<any>` to avoid strict type conflicts
- Schema types need `as unknown as ComponentSchema` cast from const assertions
- React.createElement requires `any` cast for props when using dynamic component types
- Variable interpolation should be recursive to handle nested objects and arrays
- @react-email/render accepts `{plainText: true}` option for text-only output
- D1Database type comes from `@cloudflare/workers-types`

### Iteration: 2026-01-20 (continued)

**Story:** US-019 - Seed default components into database
**Status:** Complete

**What was done:**

- Created `apps/studio/server/db/seed-email-components.ts` for seeding email components
- Implemented `seedEmailComponents(db)` function that inserts all 7 components
- Function is idempotent - checks for existing components by type before inserting
- Stores schema and defaultProps as JSON strings in the database
- Imports schemas and defaultProps directly from email-components module
- Added `updateEmailComponents(db)` function for updating existing components when definitions change
- Added `getComponentTypesToSeed()` utility function for verification
- Build passes (pre-existing typecheck error in Login.tsx unrelated)

**Files changed:**

- `apps/studio/server/db/seed-email-components.ts` (created)
- `backlog/backlog.json` (updated US-019 passes status)

**Learnings for future iterations:**

- D1/Drizzle update() doesn't have reliable `rowsAffected` property - check for existence first
- Use `eq()` from drizzle-orm for where clause conditions
- Schema and defaultProps stored as `JSON.stringify()` in text columns
- Idempotent seed functions should check existence before insert, not rely on unique constraints
- Import from parent index.ts (../email-components) to get all exports cleanly

### Iteration: 2026-01-20 (continued)

**Story:** US-020 - Create template CRUD API routes
**Status:** Complete

**What was done:**

- Added 5 template CRUD endpoints to `apps/studio/server/routes/email.ts`
- `GET /api/email/templates` returns all templates (excluding archived by default, supports `includeArchived=true` query param)
- `GET /api/email/templates/:id` returns single template with parsed JSON components and variables
- `POST /api/email/templates` creates template with name, subject, empty components array
- `PATCH /api/email/templates/:id` updates template fields including components JSON, variables, status
- `DELETE /api/email/templates/:id` soft-deletes by setting status to 'archived'
- Added 'archived' to emailTemplates status enum in schema.ts
- All template routes require authentication via authMiddleware

**Files changed:**

- `apps/studio/server/routes/email.ts` (modified - added ~170 lines for template CRUD)
- `apps/studio/server/db/schema.ts` (modified - added 'archived' to status enum)
- `backlog/backlog.json` (updated US-020 passes status)

**Learnings for future iterations:**

- SQLite stores text columns without enum constraints, so adding new enum values works without migration
- Drizzle schema enum changes only need TypeScript update, not database migration
- List endpoints should exclude soft-deleted items by default with optional query param to include them
- JSON fields stored as text need `JSON.parse()` when returning to client, `JSON.stringify()` when saving
- Use `or()` helper to filter for multiple status values in where clause

### Iteration: 2026-01-20 (continued)

**Story:** US-021 - Add template preview endpoint
**Status:** Complete

**What was done:**

- Added POST /api/email/templates/:id/preview endpoint to apps/studio/server/routes/email.ts
- Accepts optional `variables` object in request body for interpolation
- Uses existing `renderTemplate` and `getDefaultVariables` from emailRenderer service
- Returns JSON response with html, text, and merged variables (defaults + provided)
- Handles errors gracefully with appropriate error messages
- Build passes successfully

**Files changed:**

- `apps/studio/server/routes/email.ts` (modified - added ~55 lines for preview endpoint)
- `backlog/backlog.json` (updated US-021 passes status)

**Learnings for future iterations:**

- Zod schema can be made optional by wrapping in `.optional()` to allow empty request bodies
- `renderTemplate` function from emailRenderer already handles all rendering logic including variable interpolation
- `getDefaultVariables` export useful for returning the full variable context to clients
- Preview endpoints should return both rendered output AND the variables used for transparency

### Iteration: 2026-01-20 (continued)

**Story:** US-022 - Add send test email endpoint
**Status:** Complete

**What was done:**

- Added POST /api/email/templates/:id/test endpoint to apps/studio/server/routes/email.ts
- Requires `to` email address in request body (validated with Zod email schema)
- Subject prefixed with "[TEST] " for clear identification in inbox
- Uses existing `renderTemplate` and `getDefaultVariables` for sample variable interpolation
- Returns Resend message ID on success plus remaining test emails count
- Implemented rate limiting at 10 test emails per hour per authenticated user
- Rate limiting uses in-memory Map tracking userEmail -> {count, windowStart}
- Sends via existing Resend integration with dynamic import
- Build passes successfully

**Files changed:**

- `apps/studio/server/routes/email.ts` (modified - added ~126 lines for test endpoint and rate limiting)
- `backlog/backlog.json` (updated US-022 passes status)

**Learnings for future iterations:**

- Rate limiting can use Map with sliding window pattern: track count and windowStart per user
- Return `remainingTestEmails` count to help users understand their quota
- Dynamic `import('resend')` works well for on-demand module loading in routes
- Resend `emails.send()` returns `{data: {id}, error}` - check error first before accessing data
- Authenticated user available via `c.get('user')` in Hono routes with auth middleware

### Iteration: 2026-01-20 (continued)

**Story:** US-023 - Create template list page UI
**Status:** Complete

**What was done:**

- Created `apps/studio/client/pages/email/Templates.tsx` with full template list UI
- Implemented responsive grid layout for template cards (1/2/3 columns based on breakpoint)
- Added TemplateCard component showing name, subject preview, last modified date
- Implemented StatusBadge component with Draft (gray), Active (green), Archived (red) states
- Created EmptyState component with email icon and call-to-action button
- Added template API methods to `apps/studio/client/lib/api.ts`:
  - list, get, create, update, delete, preview, sendTest
- Registered `/email/templates` route in `apps/studio/client/App.tsx`
- Click on template card navigates to editor (using react-router-dom useNavigate)
- Verified in browser using chrome-devtools MCP

**Files changed:**

- `apps/studio/client/pages/email/Templates.tsx` (created)
- `apps/studio/client/lib/api.ts` (modified - added template API methods)
- `apps/studio/client/App.tsx` (modified - added route and import)
- `backlog/backlog.json` (updated US-023 passes status)

**Learnings for future iterations:**

- Template list uses grid layout pattern: `grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4`
- Button components can use `onClick` with `navigate()` from useNavigate hook
- Empty states should have both descriptive text and call-to-action button
- StatusBadge component can be shared between Templates and Campaigns pages (similar pattern)
- API types should match backend response structure exactly for TypeScript inference

### Iteration: 2026-01-20 (continued)

**Story:** US-024 - Create template editor page layout
**Status:** Complete

**What was done:**

- Created `apps/studio/client/pages/email/Editor.tsx` with three-panel layout
- Left panel: Component Library showing all 7 email component types with icons and descriptions
- Center panel: Canvas with empty state and component display (click-to-add functionality)
- Right panel: Properties panel placeholder for selected component editing
- Toolbar: Back arrow, editable template name input, Preview, Send Test, and Save buttons
- Subject line and preview text inputs above the canvas area
- Mobile responsive warning banner shown on screens < md breakpoint
- Preview modal with desktop/mobile width toggle
- Test email modal with email input and success/error states
- Registered routes for `/email/templates/new` and `/email/templates/:id`

**Files changed:**

- `apps/studio/client/pages/email/Editor.tsx` (created)
- `apps/studio/client/App.tsx` (modified - added routes and import)
- `backlog/backlog.json` (updated US-024 passes status)

**Learnings for future iterations:**

- Three-panel layout pattern: `hidden md:block` for side panels, `flex-1` for center panel
- Mobile warning uses yellow theme: `bg-yellow-500/10` with `text-yellow-800 dark:text-yellow-200`
- Component instances need unique IDs - use `${type}-${Date.now()}` pattern
- useQuery with `enabled: false` prevents fetching when condition not met (e.g., new template)
- Editor state management: separate state for each editable field, track `hasUnsavedChanges`
- Modal pattern: fixed inset-0 z-50 with bg-black/50 backdrop
- Form inputs use consistent styling: `rounded-md border border-border bg-card px-3 py-2`

### Iteration: 2026-01-20 (continued)

**Story:** US-025 - Implement component library panel in editor
**Status:** Complete

**What was done:**

- Installed @dnd-kit/core, @dnd-kit/sortable, @dnd-kit/utilities for drag-and-drop functionality
- Added DndContext wrapper with PointerSensor (8px activation distance to prevent accidental drags)
- Created DraggableComponentItem using useDraggable hook for library components
- Created CanvasDropZone using useDroppable hook as drop target
- Grouped components by category (Layout: Header, Divider, Footer; Content: Hero, TextBlock, CallToAction, ProductGrid)
- Added DragOverlay for ghost preview showing component card with primary accent colors during drag
- Updated EmptyCanvasState to show visual feedback when dragging (dashed border, "Drop component here" message)
- Canvas shows ring and background color change when dragging over it

**Files changed:**

- `apps/studio/client/pages/email/Editor.tsx` (modified - ~260 lines added/changed)
- `apps/studio/package.json` (modified - added @dnd-kit dependencies)
- `pnpm-lock.yaml` (updated)
- `backlog/backlog.json` (updated US-025 passes status)

**Learnings for future iterations:**

- @dnd-kit/core provides DndContext, useDraggable, useDroppable, DragOverlay as core primitives
- PointerSensor with `activationConstraint: {distance: 8}` prevents accidental drag starts
- useDraggable returns `{attributes, listeners, setNodeRef, isDragging}` - spread attributes/listeners on element
- useDroppable returns `{setNodeRef, isOver}` for drop target state
- DragOverlay renders outside normal DOM flow for smooth dragging (no layout shift)
- Track activeDragType in state to show appropriate feedback during drag operations
- Components can be both clickable (onClick for add) and draggable (listeners for drag)

### Iteration: 2026-01-20 (continued)

**Story:** US-026 - Implement canvas panel with sortable components
**Status:** Complete

**What was done:**

- Added @dnd-kit/sortable integration for component reordering in canvas
- Created SortableCanvasComponent using useSortable hook from @dnd-kit/sortable
- Added drag handle (GripVerticalIcon) visible on hover for each canvas component
- Implemented dual drag modes: library drag (add new) and canvas drag (reorder)
- Used SortableContext with verticalListSortingStrategy for smooth reordering
- Used arrayMove from @dnd-kit/sortable for state updates after reorder
- Added CSS.Transform for smooth drag animations
- Updated API types in api.ts to include component `id` field
- Handle legacy components without IDs when loading templates (generate IDs on load)
- Visual feedback during drag: opacity change, border highlight

**Files changed:**

- `apps/studio/client/pages/email/Editor.tsx` (modified - ~180 lines added/changed)
- `apps/studio/client/lib/api.ts` (modified - updated template component type)
- `backlog/backlog.json` (updated US-026 passes status)

**Learnings for future iterations:**

- @dnd-kit/sortable provides SortableContext, useSortable, and arrayMove for sortable lists
- useSortable returns `{attributes, listeners, setNodeRef, transform, transition, isDragging}`
- CSS.Transform.toString() converts transform to CSS string for smooth animations
- Track `isDraggingFromLibrary` to differentiate between adding new components and reordering
- Drag handles should use separate listeners from the container (onClick for select, listeners for drag)
- When checking drag source, use String(active.id).startsWith() to identify library vs canvas drags
- Component IDs should be generated on load if missing (for legacy data compatibility)

### Iteration: 2026-01-20 (continued)

**Story:** US-027 - Implement properties panel in editor
**Status:** Complete

**What was done:**

- Added COMPONENT_SCHEMAS constant with all 7 email component schema definitions client-side
- Implemented PropertiesPanel component that dynamically generates form fields from schema
- Supported input types: string (text input), textarea (multiline), color (color picker + hex input), select (dropdown), number
- Implemented array type support with add/remove item functionality (for products, socialLinks)
- Added variable hints for text fields showing "Tip: Use {{firstName}} for personalization"
- Real-time updates: changes to properties immediately update component state
- Shows "Select a component to edit its properties" when no component selected
- Schema includes label, description, required flag, default values, and options for select fields

**Files changed:**

- `apps/studio/client/pages/email/Editor.tsx` (modified - ~600 lines added)
- `backlog/backlog.json` (updated US-027 passes status)

**Learnings for future iterations:**

- Component schemas can be duplicated client-side to avoid server imports (simpler than shared package)
- Array type handling: use itemSchema to define fields for each array item
- Select values may be strings or numbers - use `String(option.value)` for option key and value attr
- For array items with select defaults, use first option value: `fieldSchema.options[0].value`
- Color picker input type="color" combined with text input provides both visual and hex editing
- Variable hints should be contextual - show for fields where personalization makes sense (text, headlines, content)

### Iteration: 2026-01-20 US-028

**Story:** US-028 - Implement template save functionality
**Status:** Complete

**What was done:**

- Added auto-save after 5 seconds of inactivity using debounced setTimeout
- Added save indicator showing "Saving..." during request
- Added save indicator showing "Saved" with timestamp on success
- Added error toast on save failure with auto-dismiss after 5 seconds
- Added unsaved changes warning modal when navigating away via back button
- Added beforeunload handler for browser tab close/refresh warning
- Used state-based navigation warning instead of useBlocker (which requires data router)

**Files changed:**

- apps/studio/client/pages/email/Editor.tsx

**Learnings for future iterations:**

- useBlocker hook requires createBrowserRouter (data router), not BrowserRouter - use state-based modal instead
- Auto-save should use a ref for the timeout to properly clear on component unmount
- isInitialLoadRef pattern prevents triggering auto-save on initial data load
- beforeunload event handler is browser-native way to warn on tab close
- For navigation warnings without data router, track pendingNavigation in state and show modal

### Iteration: 2026-01-20 US-029

**Story:** US-029 - Implement preview modal in editor
**Status:** Complete

**What was done:**

- Enhanced PreviewModal component with full functionality
- Added escape key handler using useEffect with keydown event listener
- Added backdrop click handler to close modal when clicking outside
- Prevent background scrolling when modal is open via document.body.style.overflow
- Pass sample variables (firstName: "Friend") to preview API for interpolation
- Added desktop/mobile toggle with icons (DesktopIcon, MobileIcon)
- Added proper error states when preview fails
- Added loading state with spinner during preview generation
- Display "Save template first" message for unsaved templates (templateId null)
- Show width indicator (600px/375px) and sample variable info in modal footer

**Files changed:**

- apps/studio/client/pages/email/Editor.tsx (modified - ~150 lines added, PreviewModal enhanced, added DesktopIcon and MobileIcon)

**Learnings for future iterations:**

- useEffect for keyboard events: add listener in effect, cleanup in return function
- Escape key detection: check event.key === 'Escape'
- Backdrop click: check e.target === e.currentTarget on the overlay div
- Prevent body scroll: set document.body.style.overflow = 'hidden', restore to '' in cleanup
- Modal accessibility: close on escape is expected UX behavior
- Width toggle buttons: use active state styling to show current selection
- Preview API accepts optional variables object for template interpolation

